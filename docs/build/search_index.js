var documenterSearchIndex = {"docs":
[{"location":"man/repl/#REPL-mode-1","page":"RELP","title":"REPL mode","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"AbstractLogic provides a REPL mode (thanks to ReplMaker.jl) for interacting with the parser. It is initiated by typing = in the julia console. Relp mode is an efficient method for rapidly evaluating problem sets as it is syntactically more concise.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"The REPL can be interacted with programmatically by calling the function abstractlogic(\"command\"; returnactive = false). Setting returnactive=true will return the most recent active LogicalCombo.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"julia> abstractlogic(\"clear\")\r\nClear Workspace\r\n\r\njulia> abstractlogic(\"a, b, c ∈ 1:3\")\r\na, b, c ∈ 1:3        feasible outcomes 27 ✓      :2 2 3\r\n\r\njulia> myset = abstractlogic(\"a = b|c\", returnactive = true)\r\na = b|c              feasible outcomes 15 ✓      :1 1 2\r\n\r\njulia> showfeasible(myset)\r\n15×3 Array{Int64,2}:\r\n 1  1  1\r\n 1  1  2\r\n ⋮      \r\n 3  3  3","category":"page"},{"location":"man/repl/#Basic-REPL-Interactivity-1","page":"RELP","title":"Basic REPL Interactivity","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"The repl by default will take any command that the parser will take and sent it to the logicalparser for evaluation. The primary difference is that logicalparser will return a LogicalCombo to user while the repl will keep it in active memory to be automatically referenced by future commands.","category":"page"},{"location":"man/repl/#Example-1","page":"RELP","title":"Example","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"abstractlogic> a, b, c ∈ 1:3; a = b|c\r\n\r\na, b, c ∈ 1:3        feasible outcomes 27 ✓      :2 3 3\r\na = b|c              feasible outcomes 15 ✓      :2 2 2","category":"page"},{"location":"man/repl/#REPL-Commands-1","page":"RELP","title":"REPL Commands","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Most commands should be entered directly in the REPL mode after the prompt and are executed with an enter at the end of the line.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#?...-help...-1","page":"RELP","title":"?... help...","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Returns documentation related to a function or command to the user. NOTE julia> help(...) returns identical information.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"abstractlogic> ? >\r\n  Operator: >\r\n\r\n  a > b : a is greater than b","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#back-b-1","page":"RELP","title":"back b","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Go back one command. Command next or n reverses back.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#check...-1","page":"RELP","title":"check...","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Go back one command check feasibility of subsequent command","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"### Example\r\nabstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :2 3 3\r\n\r\nabstractlogic> a > b ; b > c\r\n\r\na > b                    feasible outcomes 9 ✓           :3 2 3\r\nb > c                    feasible outcomes 1 ✓✓          :3 2 1\r\n\r\nabstractlogic> check a == 3\r\nCheck: a == 3 ... a == 3                         feasible outcomes 1 ✓✓          :3 2 1\r\ntrue, 1 out of 1 possible combinations 'true'.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#clear-[clear]-1","page":"RELP","title":"clear [clear]","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Empty the current variable space. Note Specifying the option [clear] in any part of a REPL command will call the clear function before processing the rest of the command.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"abstractlogic> a, b, c ∈ 1:3 [clear]\r\nClear Workspace\r\na, b, c ∈ 1:3            Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :1 2 1","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#clearall-1","page":"RELP","title":"clearall","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Empty the current as well as the history set space. Warning This cannot be undone!","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#dashboard-dash-1","page":"RELP","title":"dashboard dash","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Toggles the dashboard printout - primarily used for debugging.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#discover-d-1","page":"RELP","title":"discover d","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Search Main for any LogicalCombos. See Also import to bring LogicalCombo from Main and export to send LogicalCombo to Main","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#export-1","page":"RELP","title":"export","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"send LogicalCombo to Main See Also discover to search Main for any LogicalCombos and import to  bring LogicalCombo from Main.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#history-h-1","page":"RELP","title":"history h","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"\"Show command history with # feasible.\"","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#import-1","page":"RELP","title":"import","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"bring LogicalCombo from Main See Also discover to search Main for any LogicalCombos and export to send LogicalCombo to Main","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#keys-1","page":"RELP","title":"keys","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"List variables names.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#logicset-ls-1","page":"RELP","title":"logicset ls","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Show all logical sets currently in working REPL memmory.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Exiting the REPL: julia> returnactivelogicset() returns the most recent set julia> returnlogicset() returns a vector of all sets worked on int REPL","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#next-1","page":"RELP","title":"next","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Go forward one command. Only works if you have gone back first.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#preserve-1","page":"RELP","title":"preserve","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Save the current variable space for use with restore.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#restore-1","page":"RELP","title":"restore","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Restore the last saved variable space.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#search-1","page":"RELP","title":"search","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Search for the feasibility of {{i}} match","category":"page"},{"location":"man/repl/#Example-2","page":"RELP","title":"Example","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :2 3 3\r\n\r\nabstractlogic> a > b ; b > c\r\n\r\na > b                    feasible outcomes 9 ✓           :3 2 3\r\nb > c                    feasible outcomes 1 ✓✓          :3 2 1\r\n\r\nabstractlogic> search == 3\r\n\r\nChecking: a == 3\r\nChecking: b == 3\r\nChecking: c == 3\r\n\r\n:a is a match with 1 feasible combinations out of 1.\r\n:b is a not match with 0 feasible combinations out of 1.\r\n:c is a not match with 0 feasible combinations out of 1.","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#show-s-1","page":"RELP","title":"show s","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Print a table of 10 feasible results (head and tail)","category":"page"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"","category":"page"},{"location":"man/repl/#showall-1","page":"RELP","title":"showall","text":"","category":"section"},{"location":"man/repl/#","page":"RELP","title":"RELP","text":"Print a table of all feasible results.","category":"page"},{"location":"man/generators/#Generators-1","page":"Generators","title":"Generators","text":"","category":"section"},{"location":"man/generators/#The-Basic-Generator-(/in)-1","page":"Generators","title":"The Basic Generator (∈/in)","text":"","category":"section"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Abstract Logic's primary generator is the generic set declaration generator ∈. This generator takes variable names to the left separated with commas and assigns them possible values taken from the right separated with commas or specified as a range.","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Hint Initiate the repl with =.","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"abstractlogic> a, b, c ∈ 1, 2, 3 [clear]\r\nClear Workspace\r\na, b, c ∈ 1, 2, 3        Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :3 2 3\r\n\r\nabstractlogic> a, b, c ∈ 1:3 [clear]\r\nClear Workspace\r\na, b, c ∈ 1:3            Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :1 2 1\r\n\r\nabstractlogic> a, b, c ∈ A1, A2, A3 [clear]\r\nClear Workspace\r\na, b, c ∈ A1, A2, A3     Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :A3 A3 A1","category":"page"},{"location":"man/generators/#The-Conditional-Generator-(/in-condition)-1","page":"Generators","title":"The Conditional Generator (∈/in || condition)","text":"","category":"section"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"It is possible to place constraints on your data while it is being generated. This is equivalent in function to running the generator followed by specifying a constraint. However, the generator can be much more efficient it checks the constraint after generating each variable. Outcomes that have already been ruled will not need to be reevaluated as additional variables are generated.","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Because the solver is evaluating the condition after each time the variable is run, it is not clear without some math when exactly including a conditional in the generator would be more efficient rather than setting up the conditional after the generator has completed. In the following example using the conditional in the generator is equivalent to running the generator then running then specifying constraint.","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"abstractlogic> a, b, c, d, e ∈ 1:5 || {{i}} != {{!i}} [clear]\r\nClear Workspace\r\na, b, c, d, e ∈ 1:5 || {{i}} != {{!i}}           Feasible Outcomes: 120          Perceived Outcomes: 3125 ✓      :1 2 5 3 4","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Number of outcomes A, B = (55) = 25. Number of outcomes A, B, C | A != B = 5(54) = 100. Number of outcomes A, B, C, D | A != B, A != C, B != C = 5(543) = 300. Number of outcomes A, B, C, D, E | A != B, A != C, D != D, etc. 5(5432) = 600. Total Number of outcomes to evaluate: 25 + 100 + 300 + 600 = 1025.","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Equivalent to:","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"abstractlogic> a, b, c, d, e ∈ 1:5; {{i}} != {{!i}}\r\n a, b, c, d, e ∈ 1:5      Feasible Outcomes: 3125         Perceived Outcomes: 3125 ✓      :2 5 4 5 4\r\n{{i}} != {{!i}}\r\n>>> a != b ✔\r\n...\r\n>>> e != d ✔\r\n                 Feasible Outcomes: 120          Perceived Outcomes: 3125 ✓      :4 1 5 2 3","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"If you generate all of the feasible values straightaway then set the conditional the total number is just equal to number of variables V to the power of the number of possible outcomes N. In this case 5^5. Total Number of outcomes to evaluate: 3125","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Note Efficiency wise specifying {{i}} != {{!i}} is inferior to specifying {{i}} != {{>i}} as the first expression will check a != b as well as b != a while the second will only check a != b.","category":"page"},{"location":"man/generators/#The-Unique-Generator-(/in-unique)-1","page":"Generators","title":"The Unique Generator (∈/in unique)","text":"","category":"section"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"The unique generator specifies an alternative lookup function for LogicalCombo. This lookup function generates a matrix in which every item in every row occurs once and only once. These items by default have values 1, 2, ..., n though they can take alternative values by specifying them on generation.","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"abstractlogic> a, b, c, d, e ∈ unique [clear]\r\nClear Workspace\r\na, b, c, d, e ∈ unique           Feasible Outcomes: 120          Perceived Outcomes: 3125 ✓      :4 2 5 1 3\r\n\r\nabstractlogic> a, b, c, d, e ∈ 0:4 unique [clear]\r\nClear Workspace\r\na, b, c, d, e ∈ 0:4 unique       Feasible Outcomes: 120          Perceived Outcomes: 3125 ✓      :1 0 2 4 3\r\n\r\nabstractlogic> a, b, c, d, e ∈ A, B, C, D, E unique [clear]\r\nClear Workspace\r\na, b, c, d, e ∈ A, B, C, D, E unique     Feasible Outcomes: 120          Perceived Outcomes: 3125 ✓      :C D B A E","category":"page"},{"location":"man/generators/#","page":"Generators","title":"Generators","text":"Note Efficiency wise using unique is much more efficient if your data takes the form of unique values which are all used in every row. However, if your data has additional values which do not fit this","category":"page"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"CurrentModule = AbstractLogic","category":"page"},{"location":"lib/functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#General-Functions-1","page":"Functions","title":"General Functions","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"checkfeasible\r\nLogicalCombo\r\nlogicalparse\r\nlogicalrepl\r\nsearch\r\nshowfeasible","category":"page"},{"location":"lib/functions/#AbstractLogic.checkfeasible","page":"Functions","title":"AbstractLogic.checkfeasible","text":"checkfeasible(command::String, logicset::LogicalCombo; verbose=true, force=false, countany=false)\n\nIs called when the user would like to check if a command produces a valid result, possible result, or invalid result. The result is returned as a decimal from 0.0 to 1.0. With 0.0 being no matches and 1.0 being all matches.\n\nArguments\n\nverbose : controls print\nforce : all sets have to be feasible or return 0\ncountany : any set can be non-zero to return 1\n\nExamples\n\njulia> myset = logicalparse(\"a, b, c ∈ red, blue, green\")\na, b, c ∈ red, blue, green       feasible outcomes 27 ✓          :red blue blue\n\njulia> myset = logicalparse(\"a != b,c; b = c ==> a = 'blue'\", myset)\na != b,c                 feasible outcomes 12 ✓          :green blue blue\nb = c ==> a = 'blue'     feasible outcomes 8 ✓           :blue green green\n\njulia> checkfeasible(\"a = 'green' ==> b = 'red'\", myset)\nCheck: a = 'green' ==> b = 'red' ... a = 'green' ==> b = 'red'   feasible outcomes 17 ✓          :blue red green\npossible,  17 out of 21 possible combinations 'true'.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#AbstractLogic.LogicalCombo","page":"Functions","title":"AbstractLogic.LogicalCombo","text":"LogicalCombo <: Any\n\nA LogicalCombo stores the variable names, domains, as well as an binary representation of feasible values given constraints.\n\nFields\n\nkeys : Stores the names of variables.\ndomain : Stores the range of possible matches variables can have.\nlogical : A binary vector marking feasibility of length equal to every   possible combination of value which the matrix could take on.\ncommandlist : An array collection of the strings input to generate the current   state of the the object.\n\nIndexing\n\n[x,y] Where x is numeric or : and y is numeric, colon, or symbol will   return matrix point values regardless of feasibility.\n[:,:] Will collect the entire possible domain and is the same as collect().\n[x,0] Will return the logical vector values\n[x,:,true] Will return the xth feasible value of the LogicalCombo set.\n[x,:,false] Will return the xth infeasible value of the LogicalCombo set.\n\n\n\n\n\n","category":"type"},{"location":"lib/functions/#AbstractLogic.logicalparse","page":"Functions","title":"AbstractLogic.logicalparse","text":"logicalparse\n\nTakes a command and parses it into logical calls that either assigning additional feasible variable ranges or constrain the relationship between variables.\n\nlogicalparse(command::String; logicset::LogicalCombo = LogicalCombo(), verbose=true)\nlogicalparse(command::String, logicset::LogicalCombo; ...)\nlogicalparse(commands::Array{String,1}, logicset::LogicalCombo; ...)\nlogicalparse(commands::Array{String,1}; ...)\n\nArguments\n\nverbose : specifies to print to screen or not\n\nOperators\n\nThere are numerous operators available to be used in the logical parse command.\n\nExamples\n\njulia> myset = logicalparse(\"a, b, c in 1:3\")\na,b,c in 1:3             feasible outcomes 27 ✓          :3 3 3\n\njulia> myset = logicalparse(\"a == b\", myset)\na == b                   feasible outcomes 9 ✓           :1 1 2\n\njulia> myset = logicalparse(\"a > c\", myset)\na > c                    feasible outcomes 3 ✓           :3 3 1\n\njulia> myset = logicalparse(\"c != 1\", myset)\nc != 1                   feasible outcomes 1 ✓✓          :3 3 2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#AbstractLogic.search","page":"Functions","title":"AbstractLogic.search","text":"search(command::String, logicset::LogicalCombo; verbose=true)\n\nSearches for a possible match among a LogicalCombo in which the wildcard term is true. Search requires the use of a wildcard. In the event that a wildcard is missing, search will insert a {{i}} to the left of the command.{{i+1}} can be used to search for relationships between the ith column and another column.\n\nExamples\n\njulia> myset = logicalparse(\"v1, v2, v3 ∈ 1:10\")\nv1, v2, v3 ∈ 1:10        feasible outcomes 1000 ✓        :6 6 10\n\njulia> myset = logicalparse(\"{{i}} >> {{i+1}}\", myset)\n{{i}} >> {{i+1}}\n>>> v1 >> v2\n>>> v2 >> v3\n         feasible outcomes 56 ✓          :10 7 3\n\njulia> search(\"{{i}} == 4\", myset)\nChecking: v1 == 4\nChecking: v2 == 4\nChecking: v3 == 4\n\n:v1 is a not match with 0 feasible combinations out of 56.\n:v2 is a possible match with 10 feasible combinations out of 56.\n:v3 is a possible match with 6 feasible combinations out of 56.\n\njulia> search(\"== 4\", myset, verbose=false) == search(\"{{i}} == 4\", myset, verbose=false)\ntrue\n\njulia> search(\"{{i}} > {{!i}}\", myset)\nChecking: v1 > v2\nChecking: v1 > v3\nChecking: v2 > v1\nChecking: v2 > v3\nChecking: v3 > v1\nChecking: v3 > v2\n\n:v1 is a match with 56 feasible combinations out of 56.\n:v2 is a not match with 0 feasible combinations out of 56.\n:v3 is a not match with 0 feasible combinations out of 56.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#AbstractLogic.showfeasible","page":"Functions","title":"AbstractLogic.showfeasible","text":"showfeasible\n\nCollects a matrix of only feasible outcomes given the parameter space and the constraints. Use collect to output a matrix of all possible matches for parameter space.\n\nExamples\n\njulia> myset = logicalparse(\"a, b, c in 1:3\")\na,b,c in 1:3             feasible outcomes 27 ✓          :3 3 3\n\njulia> myset = logicalparse(\"a == b; c > b\", myset)\na == b                   feasible outcomes 9 ✓           :1 1 3\nc > b                    feasible outcomes 3 ✓           :2 2 3\n\njulia> showfeasible(myset)\n3×3 Array{Int64,2}:\n 1  1  2\n 1  1  3\n 2  2  3\n\n\n\n\n\n","category":"function"},{"location":"man/operators/#Standard-Relational-Operators-1","page":"Operators","title":"Standard Relational Operators","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"Standard relational operators are the core functionality of the AbstractLogic package. They allow for comparison between variables and comparison between variables and constants.","category":"page"},{"location":"man/operators/#Basic-Operators-1","page":"Operators","title":"Basic Operators","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"= or == checks that the left equals the right.\n!= (or ≠ not yet implemented) checks that the left does not equal the right.\n> checks that the left is greater than the right.\n>= checks that the left is greater than or equal to the right.\n< checks that the right is greater than the left.\n<= checks that the right is greater than or equal to the left.","category":"page"},{"location":"man/operators/#Much-Greater-Than-or-Much-Less-Than-1","page":"Operators","title":"Much Greater Than or Much Less Than","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":">> checks that the left is greater than the right by at least 2 eg. a >> b.\n<< checks that the right is greater than the left by at least 2 eg. a << b.","category":"page"},{"location":"man/operators/#Even-and-Odd-Operators-1","page":"Operators","title":"Even and Odd Operators","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"& checks if one or both sides (when two sides are present) is odd. In the case of variables defined 0,1 this asserts that one or more variables is equal to 1. eg. &a\n! checks if one or both sides (when two sides are present) is even. In the case of variables defined 0,1 this asserts that one or more variables is equal to 0. eg. !a\n^ checks if one side is odd and one side is even. eg. b ^ a","category":"page"},{"location":"man/operators/#Grouping-Syntax-1","page":"Operators","title":"Grouping Syntax","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":", on the left (or right) is treated as saying that anything on that side must conform to whatever operator follows. a, b = 1 forces a and b to equal 1.\n| on the left (or right) is treated as saying that at least one value on that side must conform to whatever operator follows. a | b = 1 forces a or b or both to equal 1. Note: a, b |= 1 is equivalent to a | b = 1 but not preferred.","category":"page"},{"location":"man/operators/#Grouping-Constraints-1","page":"Operators","title":"Grouping Constraints","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"{#,#} or {#}: it is often helpful to qualify the number of matches or syntax can make. Specifying {#} at the end of a | set will force a certain number of matches. Specifying {#1,#2} will force a number of matches no less than #1 and no more than #2.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"For example: a|b|c|d = 1 {3} will force at exactly three of the set a, b, c, and d to equal 1.","category":"page"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"julia> logicalparse(\"a, b, c, d, e ∈ 1:6; a|b|c|d = 1 {3}\")\r\na, b, c, d, e ∈ 1:6      feasible outcomes 7776 ✓        :2 5 6 6 1\r\na|b|c|d = 1 {3}                  feasible outcomes 120 ✓         :1 1 4 1 5","category":"page"},{"location":"man/operators/#Math-Operators-1","page":"Operators","title":"Math Operators","text":"","category":"section"},{"location":"man/operators/#","page":"Operators","title":"Operators","text":"AbstractLogic can take a number of standard math operators +, -, *, and / (or the rounding operator ÷). ","category":"page"},{"location":"man/superoperators/#Superoperators-1","page":"Super Operators","title":"Superoperators","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Superoperators allow AbstractLogic to evaluate multiple expressions simultaneously. Common type of expressions to be evaluated in this way are if ... then (==>), if (<==), and if only if (iff/<=>/===) statements. Generally superoperators can be identified by noting that they have three symbols together making up the operator or are strings in lowercase.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"When AbstractLogic encounters a superoperator it evaluates any expressions on either side of the superoperator. These expressions are returned as true or false. Then it follows the rules of the superoperator to evaluate the joint expression.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Constraint: a > b ==> c == a = x ==> y with x = a > b and y = c == a","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"A simple example.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"row a b c x=a > b y=c == a x ==> y\n1 2 1 1 true false false\n2 2 1 2 true true true\n3 2 2 1 false false true","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"A right arrow if constraint (==>) only holds if the left side is true. x (a > b) is true so y (c == a) must also be true. In row 1, x is true but y is not so the total statement returns false. In row 2, x is true and y is true so the total statement returns true. In row 3 the conditional statement x is false so the constraint does not bind and the total expression returns true.","category":"page"},{"location":"man/superoperators/#Operators-1","page":"Super Operators","title":"Operators","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Notationally x, y, and z will refer to operations composed of at least one operator.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-and-and-and-y-1","page":"Super Operators","title":"x &&& y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Both x and y must be true. Command end operator ; is often preferred to joint evaluators since it is more efficient. In x ; y efficiency is gained by evaluating x first, reducing the feasible set, then evaluating y.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note x and y is equivalent","category":"page"},{"location":"man/superoperators/#Example-1","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b &&& b > c\r\na > b &&& b > c                  feasible outcomes 1 ✓✓          :3 2 1","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-y-1","page":"Super Operators","title":"x ||| y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Either x or y must be true but not both. If both are false or then total expression will return false.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note x or y is equivalent","category":"page"},{"location":"man/superoperators/#Example-2","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b ||| b > c\r\na > b ||| b > c                  feasible outcomes 17 ✓          :2 2 1","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-!-y-1","page":"Super Operators","title":"x !== y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Either x or y must be true but not both. If both are false or both are true then it will return false.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note x xor y and x ^^^ y is equivalent (x and y can only be true or false)","category":"page"},{"location":"man/superoperators/#Example-3","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b ^^^ b > c\r\na > b ^^^ b > c                  feasible outcomes 16 ✓          :3 3 2","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-y-2","page":"Super Operators","title":"x === y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"If x = true then y = true or if x = false then y = false.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note x iff y and x <=> y are equivalent","category":"page"},{"location":"man/superoperators/#Example-4","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b === b > c\r\na > b === b > c                  feasible outcomes 11 ✓          :1 2 2","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-y-3","page":"Super Operators","title":"x ==> y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"If x = true then y must be true.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note if x then y and x then y are equivalent","category":"page"},{"location":"man/superoperators/#Example-5","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b ==> b > c\r\na > b ==> b > c                  feasible outcomes 19 ✓          :3 3 3","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-!-y-2","page":"Super Operators","title":"x !=> y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"If x = false then y must be true.","category":"page"},{"location":"man/superoperators/#Example-6","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b !=> b > c\r\na > b !=> b > c                  Feasible Outcomes: 17   Perceived Outcomes: 27 ✓        :3 2 1","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"","category":"page"},{"location":"man/superoperators/#x-y-4","page":"Super Operators","title":"x <== y","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"If y = true then x must be true.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note x if y is equivalent","category":"page"},{"location":"man/superoperators/#Example-7","page":"Super Operators","title":"Example","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b <== b > c\r\na > b <== b > c                  feasible outcomes 19 ✓          :3 1 1","category":"page"},{"location":"man/superoperators/#Chaining-Operators-1","page":"Super Operators","title":"Chaining Operators","text":"","category":"section"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Superoperators can be chained and when evaluated are evaluated from left to right.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note true and false are replaced dynamically in AbstractLogic with 1==1 and 1==0.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Activate the abstractlogic repl by typing = in console.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"abstractlogic> a ∈ 1\r\na ∈ 1                    feasible outcomes 1 ✓✓          :1\r\n\r\nabstractlogic> true\r\ntrue                     feasible outcomes 1 ✓✓          :1\r\n\r\nabstractlogic> false\r\nfalse                    feasible outcomes 0 X            [empty set]\r\n\r\nabstractlogic> back\r\nLast command: \"true\" - Feasible Outcomes: 1     :1\r\n\r\nabstractlogic> true or false\r\ntrue or false            feasible outcomes 1 ✓✓          :1\r\n\r\nabstractlogic> true or false and true\r\ntrue or false and true   feasible outcomes 1 ✓✓          :1\r\n\r\nabstractlogic> true xor false\r\ntrue xor false           feasible outcomes 1 ✓✓          :1\r\n\r\nabstractlogic> true xor false xor true\r\ntrue xor false xor true          feasible outcomes 0 X            [empty set]","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"The last expression returns an empty set (false) because it evaluates from left to right (true xor false) xor true which becomes (true) xor true which is then evaluated at false.","category":"page"},{"location":"man/superoperators/#","page":"Super Operators","title":"Super Operators","text":"Note Wildcards are spawned on the level right above superoperators. See Wildcards for more information.","category":"page"},{"location":"man/wildcards/#Wildcards-1","page":"Wildcards","title":"Wildcards","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"Wildcards allow for constraints which are uniformly applied across variables or sets of variables to be efficiently expressed. Uniform constraints are very common in abstract reasoning problems.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"One constraint is that each variable must take on a different values from each other variable. This is expressed typically as {{i}} != {{!i}} or more efficiently {{i}} != {{>i}}.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"The placeholder variable i represents all variable names while !i represents for any given i all variables not named i. What AbstractLogic does when it encounters wildcards is loop through possible matches spawning new constraints based on the wildcards present in the current constraint.","category":"page"},{"location":"man/wildcards/#Example-1","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :2 1 1\r\n\r\nabstractlogic> {{i}} > {{<i}}\r\n{{i}} > {{<i}}\r\n>>> b > a\r\n>>> c > a\r\n>>> c > b\r\n                 feasible outcomes 1 ✓✓          :1 2 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"In the above example we can see that three constraints were spawned from the input {{i}} > {{<i}}. This is because i is first given the variable name a but the right hand side takes value <i which means in terms of the variable set this term can take any values to the left of i which is this case is no values. So a is skipped for the i value. Next i is set to b. b only has one variable to the left a. This is evaluated. Next we look at c which has both a and b to the left which are evaluated. Finally the parser combined the joint feasibility of the three generated constraints and only keeps values in which all three are true. In this case, a=1, b=2, c=3.","category":"page"},{"location":"man/wildcards/#i-Reference-Wildcards-1","page":"Wildcards","title":"i Reference Wildcards","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{i}} the most basic wildcard reference is {{i}}. It can take any variable name from the set of variables so far defined.","category":"page"},{"location":"man/wildcards/#Example-2","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} == 1\r\n{{i}} == 1\r\n>>> a == 1\r\n>>> b == 1\r\n>>> c == 1\r\n                 feasible outcomes 1 ✓✓          :1 1 1","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{!i}} any variable not i.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"NOTE In general !i is not that helpful as there are few operations which !i does not return an empty set. And those cases in which it doesn't seem to be more efficiently expressed as >i or <i.","category":"page"},{"location":"man/wildcards/#Example-3","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} == {{!i}}\r\n{{i}} == {{!i}}\r\n>>> a == b\r\n>>> a == c\r\n>>> b == a\r\n>>> b == c\r\n>>> c == a\r\n>>> c == b\r\n                 feasible outcomes 3 ✓           :3 3 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{>i}} any variable to the right of wildcard i.","category":"page"},{"location":"man/wildcards/#Example-4","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} == {{>i}}\r\n{{i}} == {{<i}}\r\n>>> b == a\r\n>>> c == a\r\n>>> c == b\r\n                 feasible outcomes 3 ✓           :3 3 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{<i}} any variable to the left of i.","category":"page"},{"location":"man/wildcards/#Example-5","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} == {{<i}}\r\n{{i}} == {{<i}}\r\n>>> b == a\r\n>>> c == a\r\n>>> c == b\r\n                 feasible outcomes 3 ✓           :3 3 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{<<i}} any variable at least two to the left of i.","category":"page"},{"location":"man/wildcards/#Example-6","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} == {{<<i}}\r\n{{i}} == {{<<i}}\r\n>>> c == a\r\n         feasible outcomes 9 ✓           :3 1 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{>>i}} any variable at least two to the right of i.","category":"page"},{"location":"man/wildcards/#Example-7","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} == {{>>i}}\r\n{{i}} == {{>>i}}\r\n>>> a == c\r\n         feasible outcomes 9 ✓           :2 1 2","category":"page"},{"location":"man/wildcards/#i-Modifiers-Index-Modifiers-1","page":"Wildcards","title":"i Modifiers - Index Modifiers","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{i+n}}, {{i-n}} takes n steps right + or left - of i.","category":"page"},{"location":"man/wildcards/#Example-8","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} != {{i+1}}\r\n{{i}} != {{i+1}}\r\n>>> a != b\r\n>>> b != c\r\n         feasible outcomes 12 ✓          :1 2 1","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{i+n!}}, {{i-n!}} forces n steps right + or left - of i. If that step cannot be taken the variable is replaced by 999 which with numeric comparisons this will have different effects.","category":"page"},{"location":"man/wildcards/#Example-9","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} = 1 ==> {{i+1!}} = 2\r\n{{i}} = 1 ==> {{i+1!}} = 2\r\n>>> a = 1 ==> b = 2\r\n>>> b = 1 ==> c = 2\r\n>>> c = 1 ==> 999 = 2\r\n         feasible outcomes 12 ✓          :1 2 3","category":"page"},{"location":"man/wildcards/#Variable-Reference-Wildcards-1","page":"Wildcards","title":"Variable Reference Wildcards","text":"","category":"section"},{"location":"man/wildcards/#Constraints-1","page":"Wildcards","title":"Constraints","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{N}} evaluates every permutation given the wildcard set and evaluates the entire expression as true only if the number of values across wildcards is equal to N.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"Note {{N}} must appear at the end of the superoperator expression.","category":"page"},{"location":"man/wildcards/#Example-10","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} = 2 {{2}}\r\n{{i}} = 2 {{2}}\r\n>>> a = 2\r\n>>> b = 2\r\n>>> c = 2\r\n                 feasible outcomes 6 ✓           :2 2 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"Forces at least two variables from a, b, and c to equal 2.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{n1,n2}} evaluates every permutation given the wildcard set and evaluates the entire expression as true only if the number of values across wildcards is at least n1 and no more than n2. If n1 is empty then it is set to zero. If n2 is empty it is set to a large number.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"Note {{n1,n2}} must appear at the end of the superoperator expression. Hint {{,n2}} can be read as \"at most\" while {{n1,}} can be read \"at least\".","category":"page"},{"location":"man/wildcards/#Example-11","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> {{i}} = 3 {{1,2}}\r\n{{i}} = 3 {{1,2}}\r\n>>> a = 3\r\n>>> b = 3\r\n>>> c = 3\r\n         feasible outcomes 18 ✓          :2 3 3","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"Forces at least one or two of the variables to equal 3.","category":"page"},{"location":"man/wildcards/#Attributes-(j)-1","page":"Wildcards","title":"Attributes (j)","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"Variables attributes can be specified as varname.attribute and are treated as a variable except that attributes can be ignored by alternative wildcard j.","category":"page"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"{{j}} j is exactly the same as i except that it ignores the parts of variable names that come after .s. So a.1 just becomes a in the substitution mechanism.","category":"page"},{"location":"man/wildcards/#Example-12","page":"Wildcards","title":"Example","text":"","category":"section"},{"location":"man/wildcards/#","page":"Wildcards","title":"Wildcards","text":"abstractlogic> a.1,a.2 ,b.1 ,b.2, c.1, c.2  ∈ 1:3\r\na.1,a.2 ,b.1 ,b.2, c.1, c.2  ∈ 1:3       feasible outcomes 729 ✓         :2 3 3 2 3 1\r\nabstractlogic> {{j}}.1 < {{j}}.2\r\n{{j}}.1 < {{j}}.2\r\n>>> a.1 < a.2\r\n>>> b.1 < b.2\r\n>>> c.1 < c.2\r\n         feasible outcomes 27 ✓          :1 2 1 2 1 3\r\n\r\nabstractlogic> back\r\nLast command: \"a.1,a.2 ,b.1 ,b.2, c.1, c.2  ∈ 1:3\" - Feasible Outcomes: 729     :1 3 2 1 2 3\r\n\r\nabstractlogic> {{j}}.1 == {{j+1}}.2\r\n{{j}}.1 == {{j+1}}.2\r\n>>> a.1 == b.2\r\n>>> b.1 == c.2\r\n         feasible outcomes 81 ✓          :3 1 1 3 1 1","category":"page"},{"location":"man/metaoperators/#Metaoperators-1","page":"Meta Operators","title":"Metaoperators","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Metaoperators allow AbstractLogic to the conditional truth of the superoperators and operator expressions below them. Common type of expressions to be evaluated in this way are if (===> or <===) and if and only if (<==>/====) statements. Generally metaoperators can be identified by noting that they have four symbols together making up the operator or are strings in UPPERCASE.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"When AbstractLogic encounters a metaoperator it evaluates any expressions on either side of the metaoperator before attempting to evaluate the joint metaoperator. These expressions are returned as true or false. Then it follows the rules of the metaoperators to evaluate the joint expression.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"In many cases using a metaoperator will return the exact same results as a superoperator, yet when hierarchical evaluation is required metaoperators provide a valuable tool.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"A Simple example. (Activate the abstractlogic repl by typing = in console).","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a ∈ 1\r\na ∈ 1                    feasible outcomes 1 ✓✓          :1\r\n\r\nabstractlogic> true &&& false |||| false ||| true\r\ntrue &&& false |||| false ||| true       feasible outcomes 1 ✓✓          :1","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"AbstractLogic evaluated the command as follows (true & false) | (false | true) which became (false) | (true) which became true.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Note Metaoperators are less visually appealing when compared with superoperators and should be refrained from in favor of superoperators when they are available.","category":"page"},{"location":"man/metaoperators/#Operators-1","page":"Meta Operators","title":"Operators","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Notationally x, y, and z will refer to operations composed of at least one operator or superoperator.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-and-and-and-and-y-1","page":"Meta Operators","title":"x &&&& y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Both x and y must be true. Command end operator ; is often preferred to joint evaluators since it is more efficient. In x ; y efficiency is gained by evaluating x first, reducing the feasible set, then evaluating y. Note x AND y is an equivalent expression.","category":"page"},{"location":"man/metaoperators/#Example-1","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b &&&& b > c\r\na > b &&&& b > c                  feasible outcomes 1 ✓✓          :3 2 1","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-y-1","page":"Meta Operators","title":"x |||| y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"either x or y must be true. If both are false then total expression will return false. Note x OR y is equivalent","category":"page"},{"location":"man/metaoperators/#Example-2","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b |||| b > c\r\na > b |||| b > c                  feasible outcomes 17 ✓          :2 2 1","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-!-y-1","page":"Meta Operators","title":"x !=== y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Either x or y must be true but not both. If both are false or both are true then it will return false. Note x XOR y and x ^^^^ y are equivalent (x and y can only be true or false)","category":"page"},{"location":"man/metaoperators/#Example-3","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b !=== b > c\r\na > b !=== b > c                  feasible outcomes 16 ✓          :3 3 2","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-y-2","page":"Meta Operators","title":"x ==== y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"If x = true then y = true or if x = false then y = false. Note x IFF y and x <==> y are equivalent","category":"page"},{"location":"man/metaoperators/#Example-4","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b ==== b > c\r\na > b ==== b > c                  feasible outcomes 11 ✓          :1 3 3","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-y-3","page":"Meta Operators","title":"x ===> y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"If x = true then y must be true. Note IF x THEN y is equivalent","category":"page"},{"location":"man/metaoperators/#Example-5","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b ===> b > c\r\na > b ===> b > c                  feasible outcomes 19 ✓          :3 3 3","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-!-y-2","page":"Meta Operators","title":"x !==> y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"If x = false then y must be true.","category":"page"},{"location":"man/metaoperators/#Example-6","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3; a > b !==> b > c\r\n\r\na,b,c ∈ 1:3              Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :1 3 3\r\na > b !==> b > c         Feasible Outcomes: 17   Perceived Outcomes: 27 ✓        :1 3 2","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"","category":"page"},{"location":"man/metaoperators/#x-y-4","page":"Meta Operators","title":"x <=== y","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"If y = true then x must be true. Note x IF y is equivalent","category":"page"},{"location":"man/metaoperators/#Example-7","page":"Meta Operators","title":"Example","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b,c ∈ 1:3\r\na,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3\r\nabstractlogic> a > b <=== b > c\r\na > b <=== b > c                  feasible outcomes 19 ✓          :3 1 1","category":"page"},{"location":"man/metaoperators/#Chaining-Operators-1","page":"Meta Operators","title":"Chaining Operators","text":"","category":"section"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Metaoperators can be chained and when evaluated are evaluated from left to right.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Note true and false are replaced dynamically in AbstractLogic with 1==1 and 1==0.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Activate the abstractlogic repl by typing = in console.","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"abstractlogic> a,b ∈ 1,2\r\na,b ∈ 1,2                feasible outcomes 4 ✓           :2 1\r\n\r\nabstractlogic> true\r\ntrue                     feasible outcomes 4 ✓           :2 1\r\n\r\nabstractlogic> false\r\nfalse                    feasible outcomes 0 X            [empty set]\r\n\r\nabstractlogic> back\r\nLast command: \"true\" - Feasible Outcomes: 4     :1 1\r\n\r\nabstractlogic> true |||| false &&&& true\r\ntrue |||| false &&&& true        feasible outcomes 4 ✓           :1 1\r\n\r\nabstractlogic> true !=== false\r\ntrue !=== false                  feasible outcomes 4 ✓           :2 1\r\n\r\nabstractlogic> true !=== false !=== true\r\ntrue !=== false !=== true        feasible outcomes 0 X            [empty set]","category":"page"},{"location":"man/metaoperators/#","page":"Meta Operators","title":"Meta Operators","text":"Note Wildcards are spawned on the level below metaoperators. This allows multiple sets of wildcards to be evaluated separately.","category":"page"},{"location":"man/command_syntax/#Command-Flow-1","page":"Command Snytax","title":"Command Flow","text":"","category":"section"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Command flow follows a first in last out functional ruling with standard relational operators are evaluated first, then superoperators, then metaoperators. When wildcards are used, they generate code at the superoperator level which is evaluated.","category":"page"},{"location":"man/command_syntax/#Line-Break-;-1","page":"Command Snytax","title":"Line Break ;","text":"","category":"section"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Including ; in a command will break the command into two or more separate commands.","category":"page"},{"location":"man/command_syntax/#Type-of-Operators-1","page":"Command Snytax","title":"Type of Operators","text":"","category":"section"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"logicalparse takes four types operators. Generators, standard operators, superoperators, and metaoperators.","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Generators: ∈ and in are used to create or add to a LogicalCombo.","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"abstractlogic> a, b, c, d ∈ 0:2 [clear]\r\nClear Workspace\r\na, b, c, d ∈ 0:2         Feasible Outcomes: 81   Perceived Outcomes: 81 ✓        :1 0 0 2","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Standard Operators: Take the form of one or two symbol operators and are often easily identified: >, <, =, ==, != though there are many non-standard operators worth taking a look at.","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Superoperators: Evaluate the returns from operator expressions and hold three characters or lowercase strings ==>, <==, <=>, ===, !==, |||, &&&, ^^^, !=> as well as iff, if, then, and, or, and xor","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Metaoperators: Are made up of four characters or UPPERCASE characters ===>, <===, <==>, ====, !===, ||||, &&&&, ^^^^, !==>","category":"page"},{"location":"man/command_syntax/#Order-of-Operations-1","page":"Command Snytax","title":"Order of Operations","text":"","category":"section"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"For most non-trivial problems order of operations is going to be very important for programming AbstractReasoning problems.","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Standard operators are evaluated first with their values returned first to superoperators if they exist and then to metaoperators.","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"Lets take a look at a example set, \"a, b, c ∈ 1:3\". Let's say we wanted to specify that if a is less than b then c must greater than b (\"a < b <=> c > b\").","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"julia> logicalparse(\"a, b, c ∈ 1:3; a < b <=> c > b\") |> showfeasible\r\na, b, c ∈ 1:3            feasible outcomes 27 ✓          :2 3 1\r\n11×3 Array{Int64,2}:\r\n 1  1  1\r\n 1  2  3\r\n 2  1  1\r\n...\r\n 3  3  1\r\n 3  3  2\r\n 3  3  3\r\n ```\r\nFrom the array above we can see that when a is less than b, c is greater than b and when a is not less than b, c is not greater than b.\r\n\r\nThe above statement uses a *superoperator* the `<=>` which is identical to `===` and `iff`. A *metaoperator* could functionally do the same as a *superoperator* in this case. But more complex conditional assertions might exist.\r\n\r\nLets imagine same scenario as before: (if a is less than b then c must greater than b) then (a must be the same as b and c) \"a < b <=> c > b ===> a = b, c\".\r\n\r\n### Chaining Operators\r\nOperators evaluated at the same level are always evaluated from left to right.\r\n\r\nInitializing the repl (`julia> =`).\r\nThe `✓` is shorthand for `abstract logic> check ... [silent]`\r\ncalls silent check same","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"julia abstractlogic> a ∈ 1 a ∈ 1                    Feasible Outcomes: 1    Perceived Outcomes: 1 ✓✓        :1","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"abstractlogic> ✓ true ==> false false","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"abstractlogic> ✓ true &&& false ==> false true","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"abstractlogic> ✓ true &&& false ==> false &&& false false","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"\r\nFormulating a problem. Let's say we would like a constraint specifies the only time\r\n`a` is less than or equal to `b` or `c`, is when `a`, `b`, and `c` are all equal.","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"julia abstractlogic> a, b, c ∈ 1:3; a <= b ||| a <= c ==> a = b, c [clear] Clear Workspace","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"a, b, c ∈ 1:3            Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :3 3 2 a <= b ||| a <= c ==> a = b, c   Feasible Outcomes: 8    Perceived Outcomes: 27 ✓        :3 2 2","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"abstractlogic> show a b c – – – 1 1 1 2 1 1 2 2 2 3 1 1 3 1 2 3 2 1 3 2 2 3 3 3","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"\r\n## A Note On Wildcards\r\nWildcards `{{i}}` are spawned and evaluated at the level right above *superoperator* but below *metaoperators*. This allows mismatching wildcard functions to be handled on either side of a *metaoperator*. Let's say you only wanted values that either ascended monotonically or descended monotonically. You could do that using `{{i}} < {{<i}}` saying that all values to the right of `i` must be greater or `{{i}} > {{<i}}` saying that all values to the right of `i` must be smaller.\r\n","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"julia julia>  myset = logicalparse(\"a, b, c, d, e ∈ 1:6\") a, b, c, d, e ∈ 1:6      feasible outcomes 7776 ✓        :6 2 6 3 4","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"julia>  logicalparse(\"{{i}} < {{<i}} |||| {{i}} > {{<i}}\", myset) |> showfeasible logicalparse(\"{{i}} < {{<i}} |||| {{i}} > {{<i}}\", myset) |> showfeasible {{i}} < {{<i}} |||| {{i}} > {{<i}}","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"b < a c < a","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"...","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"e > c e > d","category":"page"},{"location":"man/command_syntax/#","page":"Command Snytax","title":"Command Snytax","text":"feasible outcomes 12 ✓          :1 2 3 5 6 12×5 Array{Int64,2}: 1  2  3  4  5 1  2  3  4  6 1  2  3  5  6 ... 6  5  4  2  1 6  5  4  3  1 6  5  4  3  2 ```","category":"page"},{"location":"man/getting_started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The AbstractLogic package is available through gitbub and can be installed using the following commands after entering the package REPL by typeing ] in the console.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"pkg> add https://github.com/EconometricsBySimulation/AbstractLogic.jl","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Leave the package REPL by hitting <backspace>. Now you can use the AbstractLogic package anytime by typing using AbstractLogic in Julia.","category":"page"},{"location":"man/getting_started/#Interacting-with-AbstractLogic-1","page":"Getting Started","title":"Interacting with AbstractLogic","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"There are two basic methods of interacting with the solver: logicalparse and the REPL. logicalparse is generally preferred when programmatically interacting with the solver while REPL is convenient when interacting with the solver less formally.","category":"page"},{"location":"man/getting_started/#Julia-AbstractLogic-Functions:-1","page":"Getting Started","title":"Julia AbstractLogic Functions:","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"One method is using Julia functions mainly logicalparse, checkfeasible, and search. This method relies primarily on LogicalCombo objects which are generated from and can be passed into logicalparse.","category":"page"},{"location":"man/getting_started/#logicalparse()-1","page":"Getting Started","title":"logicalparse()","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"This which evaluates abstractlogic commands to either generate data or constrain the data. The REPL will attempt to match any special REPL commands input into the REPL, if no matches are found the command is passed to logicalparse for evaluation.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"AbstractLogic.logicalparse\r\nAbstractLogic.checkfeasible\r\nAbstractLogic.search\r\nAbstractLogic.help","category":"page"},{"location":"man/getting_started/#checkfeasible()-1","page":"Getting Started","title":"checkfeasible()","text":"","category":"section"},{"location":"man/getting_started/#search-1","page":"Getting Started","title":"search","text":"","category":"section"},{"location":"man/getting_started/#help-1","page":"Getting Started","title":"help","text":"","category":"section"},{"location":"man/getting_started/#Setting-up-a-logical-set-1","page":"Getting Started","title":"Setting up a logical set","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"To set up an initial logical set. Pass a text command to logicalparse with the variable names on the left and range of possible values on the left with the ∈ or in operator in between.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"a, b, c ∈ 1, 2, 3\")\r\na, b, c ∈ 1, 2, 3        feasible outcomes 27 ✓          :3 1 3","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"logicalparse will now generate a lookup object of type LogicalCombo which tells AbstractLogic what options are feasible as well as which ones have been excluded. Every time logicalparse runs it prints the number of feasible outcomes, the number of \"percieved\" outcomes in terms of (product of the # of options) in the set given the current constraints as well as a random single feasible value that the variables can hold.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"While many logical problems do have equivalent value ranges for each variable AbstractLogic has no such constraint. Additional variables can be added to a set in an equivalent as those added upon set initiation.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"d ∈ 4,5\", logicalset)\r\nd ∈ 4,5                          feasible outcomes 54 ✓          :2 1 1 5","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Variable values need not be of the same type.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"bob, ali ∈ old, young\", logicalset)\r\nbob, ali ∈ old, young    feasible outcomes 216 ✓         :3 2 3 5 young old","category":"page"},{"location":"man/getting_started/#Constraining-the-logical-set-1","page":"Getting Started","title":"Constraining the logical set","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"logicalparse is also the command used to set constraints on the logical set. These constraints are defined through use of operators expressing relationships between variables or constants.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Forcing variable a to take on the same value as variable c we could write.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"a = c\", logicalset)\r\na = c                    feasible outcomes 72 ✓          :2 3 2 5 young young","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We can also force variables to take the value of a constant.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"b = 2\", logicalset)\r\nb = 2                    feasible outcomes 24 ✓          :2 2 2 4 old old","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Though constant strings need be quoted as they would otherwise be attempted to be parsed as variables.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"ali = 'old'\", logicalset)\r\nali = 'old'              feasible outcomes 12 ✓          :3 2 3 4 old old","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Perhaps we would like to force Ali to be a different age than Bob.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> logicalset = logicalparse(\"ali != bob\", logicalset)\r\nali != bob               feasible outcomes 6 ✓           :2 2 2 4 young old","category":"page"},{"location":"man/getting_started/#Checking-the-Feasibility-of-a-Statement-1","page":"Getting Started","title":"Checking the Feasibility of a Statement","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We might often like to check the feasiblility of a claim. Perhaps we would like to ask if Bob is young.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> checkfeasible(\"bob == 'young'\", logicalset)\r\nCheck: bob == 'young' ... bob == 'young'                 feasible outcomes 6 ✓           :3 2 3 4 young old\r\ntrue, 6 out of 6 possible combinations 'true'.\r\n2-element Array{Any,1}:\r\n 1.0\r\n\r\n  LogicalCombo(Symbol[:a, :b, :c, :d, :bob, :ali], Array{T,1} where T[[1, 2, 3], [1, 2, 3], [1, 2, 3], [4, 5], [\"old\", \"young\"], [\"old\", \"young\"]], Bool[false, false, false, false, false, false, false, false, false, false  …  false, false, false, false, false, false, false, false, false, false])","category":"page"},{"location":"man/getting_started/#Search-for-a-Possible-Match-1","page":"Getting Started","title":"Search for a Possible Match","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We might instead want to ask the question, which variables could take on a value equal to 3.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> search(\"== 3 \", logicalset)\r\nChecking: a == 3\r\nChecking: b == 3\r\nChecking: c == 3\r\nChecking: d == 3\r\nChecking: bob == 3\r\nChecking: ali == 3\r\n\r\n:a is a possible match with 2 feasible combinations out of 6.\r\n:b is a not match with 0 feasible combinations out of 6.\r\n:c is a possible match with 2 feasible combinations out of 6.\r\n:d is a not match with 0 feasible combinations out of 6.\r\n:bob is a not match with 0 feasible combinations out of 6.\r\n:ali is a not match with 0 feasible combinations out of 6.\r\n6-element Array{Float64,1}:\r\n 0.3333333333333333\r\n 0.0\r\n 0.3333333333333333\r\n 0.0\r\n 0.0\r\n 0.0","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"From this we can see that variables a and c are possible matches.","category":"page"},{"location":"man/getting_started/#Julia-REPL-1","page":"Getting Started","title":"Julia REPL","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Alternatively you can interact with the logical problem solver through the repl interface. It is initiated by in julia by typing = in julia> repl.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"abstractlogic>","category":"page"},{"location":"man/getting_started/#Setting-up-a-logical-set-2","page":"Getting Started","title":"Setting up a logical set","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The interface is much cleaner to work with.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"abstractlogic> a, b, c ∈ 1, 2, 3\r\na, b, c ∈ 1, 2, 3        feasible outcomes 27 ✓          :1 3 3\r\n\r\nabstractlogic> d ∈ 3, 4, 5\r\nd ∈ 3, 4, 5              feasible outcomes 81 ✓          :2 3 3 4\r\n\r\nabstractlogic> e,f in red, green, blue\r\ne,f ∈ red, green, blue   feasible outcomes 729 ✓         :2 3 3 4 red red","category":"page"},{"location":"man/getting_started/#Constraining-the-logical-set-2","page":"Getting Started","title":"Constraining the logical set","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Writing contraints within the repl is equivalent to that of logicalparse.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"abstractlogic> a = c\r\na = c                    feasible outcomes 243 ✓         :3 1 3 3 red blue\r\n\r\nabstractlogic> e != f\r\ne != f                   feasible outcomes 162 ✓         :1 1 1 3 blue green","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We can also force variables to take the value of a constant.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"abstractlogic> f = 'blue'\r\nf = 'blue'               feasible outcomes 54 ✓          :2 3 2 4 red blue","category":"page"},{"location":"man/getting_started/#Checking-the-Feasibility-of-a-Statement-2","page":"Getting Started","title":"Checking the Feasibility of a Statement","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We might often like to check the feasiblility of a claim. This is done with the check command","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"abstractlogic> check a=2\r\nCheck: a=2 ... a=2                       feasible outcomes 18 ✓          :2 1 2 4 green blue\r\npossible,  18 out of 54 possible combinations 'true'.","category":"page"},{"location":"man/getting_started/#Search-for-a-Possible-Match-2","page":"Getting Started","title":"Search for a Possible Match","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We might instead want to ask the question, which variables could take on a value equal to 3.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"abstractlogic> search ==3\r\n\r\nChecking: a ==3\r\nChecking: b ==3\r\nChecking: c ==3\r\nChecking: d ==3\r\nChecking: e ==3\r\nChecking: f ==3\r\n\r\n:a is a possible match with 18 feasible combinations out of 54.\r\n:b is a possible match with 18 feasible combinations out of 54.\r\n:c is a possible match with 18 feasible combinations out of 54.\r\n:d is a possible match with 18 feasible combinations out of 54.\r\n:e is a not match with 0 feasible combinations out of 54.\r\n:f is a not match with 0 feasible combinations out of 54.","category":"page"},{"location":"#AbstractLogic.jl-1","page":"Introduction","title":"AbstractLogic.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to AbstractLogic documentation!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This resource aims at teaching you everything you will need for using the intuitive Abstract Logic problem solver in the Julia language.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#What-is-an-abstract-logic-solver?-1","page":"Introduction","title":"What is an abstract logic solver?","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Abstract logic problems come in many forms. This solver specifically is built to handle verbal abstract logic problems which have a finite number of possible permutations. Verbal abstract reasoning problems are often found in cognitive testing environments such as employee aptitude testing and prominently as a section on the Law School Entrance Exam.","category":"page"},{"location":"#Why-an-abstract-logic-solver?-1","page":"Introduction","title":"Why an abstract logic solver?","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The cost of hand writing and evaluating items can be expensive. Abstract logic items are easy to write but relatively hard to evaluate. This package goes a long way to reducing the cost of evaluating items and is intended as a tool to aid in the generation of large batches of abstract reasoning items.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The need for large batches of items stems from a great deal of interest by test takers in illegally obtaining copies of items from high stakes exams. Cheating on high stakes exams is known to be common. This forces testing companies to spend a great deal of resources protecting their intellectual capital while also creating an environment in which they finds themselves vulnerable to accusations of secrecy. Producing tools that reduce the cost of generating and evaluating items has the promise of alleviating concerns over item exposure.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In addition to the benefit to testing companies of reduced cost items, reducing the cost of items has the promise of aiding in the production of items for the use by researchers and companies interested in evaluating the efforts and aptitudes of their employees who do not have the means of producing their own instrument or of obtaining and providing a secure environment for the deployment of a commercial instrument.","category":"page"},{"location":"#A-Simple-Example-1","page":"Introduction","title":"A Simple Example","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"A typical kind of problem which one might have encountered in an aptitude test at some point in ones life might look like the following.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Peter is younger than Susan. Sam is younger than Susan but older than Ali.\r\nLi is older than Ali younger than Peter.\r\n\r\n1. Who must be the oldest?\r\na) Peter b) Susan c) Sam d) Li e) Ali f) Cannot Tell\r\n\r\n2. Who must be the youngest?\r\na) Peter b) Susan c) Sam d) Li e) Ali f) Cannot Tell\r\n\r\n3. Who could be the same age as Li?\r\na) Peter b) Susan c) Sam d) Ali e) Nobody f) Cannot Tell","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The package AbstractLogic provides a tool for easily evaluating such problems. First lets load in the feasible matches. Because there are 5 people in the problem we can assign them 5 age categories which represent cardinal ordered ages.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Let's input this problem into Abstract Logic syntax.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using AbstractLogic\r\nStart the repl in command prompt by typing `=`.\r\n\r\nabstractlogic> Peter, Susan, Sam, Li, Ali ∈ 1, 2, 3, 4, 5 [clear]\r\nClear Workspace\r\nPeter, Susan, Sam, Li, Ali ∈ 1, 2, 3, 4, 5       Feasible Outcomes: 3125         Perceived Outcomes: 3125 ✓      :1 3 4 1 1\r\n\r\nabstractlogic> Peter < Susan; Sam < Susan\r\n\r\nPeter < Susan            Feasible Outcomes: 1250         Perceived Outcomes: 2000 ✓      :1 2 2 1 2\r\nSam < Susan              Feasible Outcomes: 750          Perceived Outcomes: 1600 ✓      :1 2 1 5 4\r\n\r\nabstractlogic> Sam > Ali; Li > Ali; Li < Peter\r\n\r\nSam > Ali                Feasible Outcomes: 175          Perceived Outcomes: 540 ✓       :1 5 3 4 1\r\nLi > Ali                 Feasible Outcomes: 121          Perceived Outcomes: 432 ✓       :1 4 3 5 1\r\nLi < Peter               Feasible Outcomes: 13   Perceived Outcomes: 48 ✓        :3 5 4 2 1","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Now that we have input our constraints we can start asking our questions.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Question 1. Who must be the oldest?","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> search {{i}} > {{!i}}\r\n  Checking: Peter > Susan Checking: Peter > Sam ... Checking: Ali > Sam Checking: Ali > Li\r\n\r\n:Peter is a not match with 0 feasible combinations out of 13.\r\n:Susan is a match with 13 feasible combinations out of 13.\r\n:Sam is a not match with 0 feasible combinations out of 13.\r\n:Li is a not match with 0 feasible combinations out of 13.\r\n:Ali is a not match with 0 feasible combinations out of 13.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"From this we can see that Susan is the oldest.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Question 2. Who must be is the youngest? To check who is the youngest we can do the same but this time setting verbose=false to reduce the printing.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> search {{i}} < {{!i}}\r\n  Checking: Peter < Susan Checking: Peter < Sam ... Checking: Ali < Sam Checking: Ali < Li\r\n\r\n:Peter is a not match with 0 feasible combinations out of 13.\r\n:Susan is a not match with 0 feasible combinations out of 13.\r\n:Sam is a not match with 0 feasible combinations out of 13.\r\n:Li is a not match with 0 feasible combinations out of 13.\r\n:Ali is a match with 13 feasible combinations out of 13.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The search function returns a ratio of feasible outcomes for each column relative to total outcomes. A zero means no feasible combination exist that match while a 1 indicates a 100% match.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Question 3. Who could be the same age as Li?","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> search {{i}} = Li\r\n  Checking: Peter = Li Checking: Susan = Li ... Checking: Li = Li Checking: Ali = Li\r\n\r\n:Peter is a not match with 0 feasible combinations out of 13.\r\n:Susan is a not match with 0 feasible combinations out of 13.\r\n:Sam is a possible match with 5 feasible combinations out of 13.\r\n:Li is a match with 13 feasible combinations out of 13.\r\n:Ali is a not match with 0 feasible combinations out of 13.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"From the results we can see that Sam could share ages with Li.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"But Abstract Logic can handle problems much more complex then simple inequalities!","category":"page"},{"location":"#A-More-Complex-Example-1","page":"Introduction","title":"A More Complex Example","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"You would like to figure out your plans for the evenings this week. Each evening\r\ncan do only one activity at most. There are only four options for what you can do\r\neach night: call home, work out, homework, or eat out with friends.\r\nEach week begins on Monday and ends on Sunday.\r\n\r\nYour schedule is subject to the following constraints:\r\nYou do homework at least twice a week\r\nYou work out at least twice a week\r\nYou do not work out on sequential days\r\nYou only eat out if the next day you work out.\r\nYou must call home at least once and at least three days after the last call.\r\nWhatever you do on Fri must be different from what you do on Sat or Sun.\r\nYou must do homework at least one night on Monday, Tuesday, or Wednesday\r\nYou eat out at least twice per week.\r\n\r\nQuestions:\r\n1. Given these constraints what is the most number of times you can work out each week?\r\na) two b) three c) four\r\n\r\n2. If you do homework on Monday what must be true?\r\na) Friday you do not do homework\r\nb) Wednesday you do not call home\r\nc) Saturday you do not workout\r\nd) Tuesday you do not workout\r\n\r\n3. Which of the following must be true?\r\na) If you call home on Mon then your Tue and Fri activity must be the same.\r\nb) If you call home on Tues then your Mon and Fri activity must be the same.\r\nc) If you call home on Wed then your Mon and Sat activity must be the same.\r\nd) If you call home on Fri then your Tues and Sun activity must be the same.\r\ne) If you call home on Sat then your Mon and Wed activity must be the same.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Let's input this problem into Abstract Logic syntax.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using AbstractLogic\r\nStart the repl in command prompt by typing `=`.\r\n\r\nabstractlogic> mo, tu, we, th, fr, sa, su ∈ call, gym, hmwk, eat [clear]\r\nClear Workspace\r\nmo, tu, we, th, fr, sa, su ∈ call, gym, hmwk, eat        Feasible Outcomes: 16384        Perceived Outcomes: 16384 ✓     :eat hmwk eat eat call hmwk eat","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You do homework at least twice a week","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> {{i}} = 'hmwk' {{2,}}\r\n{{i}} = 'hmwk' {{2,}}  >>> mo = 'hmwk' >>> tu = 'hmwk' ... >>> sa = 'hmwk' >>> su = 'hmwk' {{2,∞}}\r\n         Feasible Outcomes: 9094         Perceived Outcomes: 16384 ✓     :eat call hmwk hmwk gym gym call","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You work out at least twice a week","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> {{i}} = 'gym' {{2,}}\r\n{{i}} = 'gym' {{2,}}  >>> mo = 'gym' >>> tu = 'gym' ... >>> sa = 'gym' >>> su = 'gym' {{2,∞}}\r\n         Feasible Outcomes: 4172         Perceived Outcomes: 16384 ✓     :gym hmwk hmwk eat gym eat gym","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You do not work out on sequential days","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic>  {{i}} == 'gym' ==> {{i}} != {{i+1}}\r\n{{i}} == 'gym' ==> {{i}} != {{i+1}}  >>> mo == 'gym' ==> mo != tu >>> tu == 'gym' ==> tu != we ... >>> fr == 'gym' ==> fr != sa >>> sa == 'gym' ==> sa != su\r\n         Feasible Outcomes: 2302         Perceived Outcomes: 16384 ✓     :gym call hmwk eat hmwk call gym","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You only eat out if the next day you work out. The ! in {{i+1!}} tells the spawner to swap OUTOFBOUNDS with 999 for comparison purposes.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> {{i}} = 'eat' ==> {{i+1!}} = 'gym'\r\n{{i}} = 'eat' ==> {{i+1!}} = 'gym'  >>> mo = 'eat' ==> tu = 'gym' >>> tu = 'eat' ==> we = 'gym' ... >>> sa = 'eat' ==> su = 'gym' >>> su = 'eat' ==> 999 = 'gym'\r\n         Feasible Outcomes: 936          Perceived Outcomes: 12288 ✓     :call gym hmwk gym hmwk hmwk gym","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Since the week ends on Sunday we cannot count on working out on Monday. This constraint is redundant since this has already been restricted from the ! in the last expression.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> su != 'eatout'\r\nsu != 'eatout'           Feasible Outcomes: 936          Perceived Outcomes: 12288 ✓     :hmwk gym hmwk call call hmwk gym","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You must call home at least once and any follow up calls have to be three after the last call.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> {{i}} = 'call' {{1,}}; {{i}} = 'call' ==> {{<i+3,>i}} != 'call'\r\n\r\n{{i}} = 'call' {{1,}}  >>> mo = 'call' >>> tu = 'call' ... >>> sa = 'call' >>> su = 'call' {{1,∞}}\r\n         Feasible Outcomes: 830          Perceived Outcomes: 12288 ✓     :gym call gym hmwk call call hmwk\r\n{{i}} = 'call' ==> {{<i+3,>i}} != 'call'  >>> mo = 'call' ==> tu != 'call' >>> mo = 'call' ==> we != 'call' ... >>> fr = 'call' ==> su != 'call' >>> sa = 'call' ==> su != 'call'\r\n         Feasible Outcomes: 496          Perceived Outcomes: 12288 ✓     :call gym hmwk hmwk hmwk gym hmwk","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Let's check if that least command is doing what we expect. Lets restrict ourselves to the cases in which we call home at least twice.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> {{i}} = 'call' {{2,}}\r\n{{i}} = 'call' {{2,}}  >>> mo = 'call' >>> tu = 'call' ... >>> sa = 'call' >>> su = 'call' {{2,∞}}\r\n         Feasible Outcomes: 176          Perceived Outcomes: 12288 ✓     :call hmwk gym hmwk call gym hmwk","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Let's see what they look like. Yeap, none of them feature calls closer than 3 days apart.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> show\r\n  Showing 10 of 176 rows\r\n\r\n mo  tu   we   th   fr   sa   su\r\n–––– ––– –––– –––– –––– –––– ––––\r\ncall gym hmwk call gym  hmwk call\r\ncall gym hmwk call gym  hmwk gym\r\ncall gym hmwk call gym  hmwk hmwk\r\ncall gym hmwk call hmwk gym  call\r\ncall gym hmwk call hmwk gym  hmwk\r\n ⋮    ⋮   ⋮    ⋮    ⋮    ⋮    ⋮\r\neat  gym call hmwk gym  hmwk call\r\neat  gym call hmwk hmwk call gym\r\neat  gym call hmwk hmwk gym  call\r\neat  gym hmwk call gym  hmwk call\r\neat  gym hmwk call hmwk gym  call","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> back\r\nLast command: \"{{i}} = 'call' {{1,}}; {{i}} = 'call' ==> {{<i+3,>i}} != 'call'\" - Feasible Outcomes: 496         Perceived Outcomes: 12288      :call call gym gym hmwk hmwk hmwk","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Whatever you do on Friday must be different from what you do on Saturday or Sunday.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> fr != sa, su\r\nfr != sa, su             Feasible Outcomes: 319          Perceived Outcomes: 12288 ✓     :gym call hmwk hmwk hmwk gym call","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You must do homework at least one night on Monday, Tuesday, or Wednesday","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> mo | tu | we = 'hmwk'\r\nmo | tu | we = 'hmwk'    Feasible Outcomes: 278          Perceived Outcomes: 12288 ✓     :call hmwk gym eat gym hmwk hmwk","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Would like to eat out at least twice per week.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> {{i}} = 'eat' {{2,}}\r\n{{i}} = 'eat' {{2,}}  >>> mo = 'eat' >>> tu = 'eat' ... >>> sa = 'eat' >>> su = 'eat' {{2,∞}}\r\n         Feasible Outcomes: 18   Perceived Outcomes: 6912 ✓      :eat gym hmwk eat gym hmwk call","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Now for us to address the questions:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> silence\r\nSilencing REPL print. Reverse with command 'noisy'","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Question 1. Given these constraints what is the most number of times you can work out each week?","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"a) two b) three c) four","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> check: {{i}} = 'gym' {{2}}\r\ntrue","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Question 2. If you do homework on Monday what must be true?","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"First we will preserve the current state of the data so that we can reverse the preserve.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> preserve\r\nPreserving State\r\n\r\nabstractlogic> mo = 'hmwk'","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"a) Tuesday you do not eat out","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: tu != 'eat'\r\nfalse","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"b) Wednesday you do not call home","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: we != 'call'\r\ntrue","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"c) Friday you do not do homework","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: fr != 'hmwk'\r\nfalse","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"d) Saturday you do not workout","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: sa != 'gym'\r\nfalse","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Return to the state before requiring us to do homework on Monday.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> restore\r\nRestoring State - Feasible Outcomes: 18          Perceived Outcomes: 6912       :call eat eat gym gym hmwk hmwk","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Question 3. Which of the following must be true? a) If you call home on Monday then your Tuesday and Friday activity must be the same.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: mo == 'call' ==> tu == fr\r\nfalse","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"b) If you call home on Tuesday then your Monday and Friday activity must be the same.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: tu == 'call' ==> mo == fr\r\nfalse","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"c) If you call home on Wednesday then your Monday and Saturday activity must be the same.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: we == 'call' ==> mo == sa\r\ntrue","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"d) If you call home on Friday then your Tuesday and Sunday activity must be the same.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: fr == 'call' ==> tu == su\r\nfalse","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"e) If you call home on Saturday then your Monday and Wednesday activity must be the same.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"abstractlogic> prove: sa == 'call' ==> mo == we\r\nfalse","category":"page"}]
}
