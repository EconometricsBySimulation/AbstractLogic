        - 
        - # Functions:
        - # reportfeasible
        - # subout
        - # back
        - 
        - ##########################################################################
        - ##########################################################################
        - 
        - function reportfeasible(logicset::LogicalCombo;
        -     command=""::String,
        -     verbose=true::Bool)::LogicalCombo
        - 
       32     !verbose && return logicset
       13     filler = repeat("\t", max(1, 3-Integer(floor(length(command)/8))))
        - 
       13     Nfeas = nfeasible(logicset)
       13     Perceived = percievedfeasible(logicset)
        - 
       13     (Nfeas == 0)  && (check = "X ")
       13     (Nfeas  > 1)  && (check = "✓ ")
       13     (Nfeas == 1)  && (check = "✓✓")
        - 
       13     ender = (Nfeas>0) ? ":" *
        -       join(logicset[rand(1:Nfeas),:,:], " ") : " [empty set]"
        - 
       13     println(" $filler Feasible Outcomes: $Nfeas \t Perceived Outcomes: $Perceived $check \t $ender")
       13     return logicset
        - end
        - 
        3 reportfeasible(command::String, verbose::Bool)::Function =
       16   (x -> reportfeasible(x, command=command, verbose=verbose))
        - 
        - ##########################################################################
        - ##########################################################################
        - 
        - function subout(txtcmd, i, arg, mykeys)
       48   lookup(vect, i) = i ∈ 1:length(vect) ? vect[i] : "~~OUTOFBOUNDS~~"
        - 
       36   (arg[end] ∈ ['i', 'j', 'J'])  && return replace(txtcmd, "{{$arg}}"=>lookup(mykeys,i))
        - 
        2   mod = integer(match(r"([0-9]+$)", arg).match)
        - 
        1   occursin("+", arg) && return replace(txtcmd, "{{$arg}}"=>lookup(mykeys,i+mod))
        0   occursin("-", arg) && return replace(txtcmd, "{{$arg}}"=>lookup(mykeys,i-mod))
        - 
        0   txtcmd
        - end
        - 
        - subout("{{i + 1}}", 1, "i + 1", [:a,:b,:c,:d])
        - 
        - ##########################################################################
        - ##########################################################################
        - 
        - function stringnumparse(x)
       28     !occursin(r"\+|\-",x) && return integer(x)
        - 
        0     x2 = split(x, r"\+|\-")
        - 
        0     occursin("+", x) && return +(integer.(x2)...)
        0     occursin("-", x) && return -(integer.(x2)...)
        - 
        0     throw("$x not interpreted!")
        - end
        - 
        - ##########################################################################
        - ##########################################################################
        - 
        0 Base.:+(x::String, y::String) = x * " " * y
        - 
        - function skipthischeck(txt, i, j; verbose=false)
       28     txt = replace(txt, " "=>"")
        - 
       14     occursin(r"!(i|j|J)", txt) && return i==j
        - 
       14     occursin(r"![0-9]+$", txt) &&
        -      return integer(match(r"^!([0-9])+$", txt).captures[1]) == j
        - 
       14     occursin(r"^!(i|j|J)$", txt) && (i  == j) && return true
        - 
       14       m = match(r"^\*?([>=<]{0,2})(.*)([>=<]{0,2})\*?$", txt)
       28       if m.match != nothing
       14         centernum = stringnumparse(strip.(m.captures[2]))
       14         verbose && print(" (" +
        -          (m.captures[1] == "" ? "" : string(j) + string(m.captures[1])) *
        -            " $centernum " *
        -          (m.captures[3] == "" ? "" : string(m.captures[3]) + string(j)) * ") ")
        -         # * [operator] center
       14         (m.captures[1] == ">")  && !(j >  centernum    ) && return true
        4         (m.captures[1] == ">=") && !(j >= centernum    ) && return true
        4         (m.captures[1] == ">>") && !(j >  centernum + 1) && return true
        4         (m.captures[1] == "<")  && !(j <  centernum    ) && return true
        4         (m.captures[1] == "<=") && !(j <= centernum    ) && return true
        4         (m.captures[1] == "<<") && !(j <  centernum - 1) && return true
        - 
        -         # center [operator] *
        4         (m.captures[3] == "<")  && !(centernum     <  j) && return true
        4         (m.captures[3] == "<=") && !(centernum     <= j) && return true
        4         (m.captures[3] == "<<") && !(centernum - 1 << j) && return true
        4         (m.captures[3] == ">")  && !(centernum     >  j) && return true
        4         (m.captures[3] == ">=") && !(centernum     >= j) && return true
        4         (m.captures[3] == ">>") && !(centernum + 1 >> j) && return true
        - 
        4         (m.captures[1] ∈ ["=","=="]) && (centernum != j) && return true
        4         (m.captures[3] ∈ ["=","=="]) && (centernum != j) && return true
        -       end
        4     false
        - end
        - 
        - ##########################################################################
        - ##########################################################################
        - 
        - function splitthenskipcheck(txt, i, j; verbose=false)
       70     rangematchessplit =
        -        strip.(split(replace(txt, r"i|j|J"=>i), r"(,|\|)"))
        - 
       14     occursin("|", txt) && return all(skipthischeck.(rangematchessplit, i, j, verbose=verbose))
        - 
       14     !occursin("|", txt) && return any(skipthischeck.(rangematchessplit, i, j, verbose=verbose))
        - 
        0     false
        - end
        - 
        - # txt = "!1,!3"
        - #
        - # for i in 1:5, j in 1:5
        - #     print("i = $i, j = $j skipthis {{$txt}} Skip? ")
        - #     println(splitthenskipcheck(txt, i, j, verbose=true))
        - # end
        - #
        - 
        - ##########################################################################
        - ##########################################################################
        - 
        - function back(logicset::LogicalCombo; verbose=false)
        -   (length(logicset.commands)==0) && (println("Nothing to go back to!"); return logicset)
        -   commandlist = copy(logicset.commands)
        -   pop!(commandlist)
        -   return logicalparse(commandlist, verbose=verbose)
        - end
        - 
