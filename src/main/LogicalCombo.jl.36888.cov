        - """
        -     LogicalCombo <: Any
        - 
        - A LogicalCombo stores the variable names, domains, as well as an binary
        - representation of feasible values given constraints.
        - 
        - **Fields**
        - 
        - * keys : Stores the names of variables.
        - * domain : Stores the range of possible matches variables can have.
        - * logical : A binary vector marking feasibility of length equal to every
        -     possible combination of value which the matrix could take on.
        - * commandlist : An array collection of the strings input to generate the current
        -     state of the the object.
        - 
        - **Indexing**
        - 
        - * [x,y] Where x is numeric or : and y is numeric, colon, or symbol will
        -     return matrix point values regardless of feasibility.
        - * [:,:] Will collect the entire possible domain and is the same as `collect()`.
        - * [x,0] Will return the logical vector values
        - * [x,:,true] Will return the xth feasible value of the LogicalCombo set.
        - * [x,:,false] Will return the xth infeasible value of the LogicalCombo set.
        - """
        - struct LogicalCombo
       53   keys::Array{Symbol}
        -   domain::AbstractArray
        -   logical::Array{Bool}
        -   lookup::Function
        -   type::String
        -   commands::Array{String}
        - end
        - 
       61 LogicalCombo(keys, domain, logical) =
        -     LogicalCombo(keys, domain, logical, permutationlookup, "Permutation", String[])
        - 
        2 LogicalCombo(keys, domain, logical, permutationlookup, type) =
        -     LogicalCombo(keys, domain, logical, permutationlookup, type, String[])
        - 
        - LogicalCombo() = LogicalCombo(Symbol[],[], Bool[])
        - 
        - function LogicalCombo(; kwargs...)
       68     if isempty(kwargs)
       30         return LogicalCombo(Symbol[],[], Bool[])
        -     else
        -         keys = []; domain = []
        -         for (kw, val) in kwargs;
        -             push!(keys, kw)
        -             push!(domain, val)
        -         end
        -     end
        -     LogicalCombo(keys, domain, fill(true,*(length.(domain)...)))
        - end
        - 
        - function LogicalCombo(x::Union{AbstractArray{Pair{Symbol, Any}}, Array{Pair{Symbol,UnitRange{Int64}},1}})
        4     if length(x) == 0
        0         return LogicalCombo(Symbol[],[], Bool[0])
        -     else
        4         mykeys = []; mydomain = []
        8         for (kw, val) in x;
        -             push!(mykeys, kw)
        8             push!(mydomain, val)
        -         end
        -     end
        2     LogicalCombo(mykeys, mydomain, fill(true,*(length.(mydomain)...)))
        - end
        - 
       14 Base.keys(x::LogicalCombo)     = x.keys
     6333 domain(x::LogicalCombo)        = x.domain
    11718 Base.size(x::LogicalCombo)     = [length(x.logical), length(x.keys)]
       90 Base.size(x::LogicalCombo, y::Integer) = size(x)[y]
        - 
        - function permutationlookup(x::LogicalCombo, row::Integer, col::Integer)
        -     # Divisor is calculating based on how many values remains how many times to repeat the current value
     8782     divisor = (col+1 > size(x)[2] ? 1 : x.domain[(col+1):size(x)[2]] .|> length |> prod)
        -     # indexvalue finds the index to select from the column of interest
     6312     indexvalue = (Integer(ceil(row / divisor)) - 1) % length(domain(x)[col]) + 1
     3156     domain(x)[col][indexvalue]
        - end
        - 
        - function permutationuniquelookup(x::LogicalCombo, row::Integer, col::Integer)
       63     n = size(x,2)
       21     fset = 1:n
        -     y = row
        -     z = 0
       21     setout = Integer[]
       42     for j in 1:col
       42         K = factorial(n-j)
       42         z = Integer(ceil(y/ K))
       42         y = y - (z-1) * K
       42         push!(setout, fset[z])
       63         fset = fset[[(1:(z-1))..., ((z+1):length(fset))...]]
        -     end
       21     domain(x)[setout[col]]
        - end
        - 
        - function Base.getindex(x::LogicalCombo, row::Integer, col::Integer)
     6360     (col==0) && (row==0) && return :keys
     3180     (row==0) && return keys(x)[col]
     3177     (col==0) && return x.logical[row]
     3177     x.lookup(x, row, col)
        - end
        - 
        0 Base.collect(x::LogicalCombo; bool::Bool=true, varnames::Bool=true) =
        -   [x[i,j] for i in !varnames:size(x)[1], j in !bool:size(x)[2]]
        - 
        - function Base.getindex(x::LogicalCombo, row::Integer, col::Symbol)
     4900   keymatch = findall(y -> y == col , x.keys)
     2450   length(keymatch)==0 && throw("Symbol :$col not found")
     2446   x[row, keymatch...]
        - end
        - 
      274 Base.getindex(x::LogicalCombo, ::Colon) =  x.logical
        - Base.getindex(x::LogicalCombo, y::Union{Int64,UnitRange}) =  x.logical[y]
        - Base.getindex(x::LogicalCombo, y::Union{Array}) =
        -   [x[i,j] for i in (1:size(x)[1])[x[:] .& y], j in 1:size(x)[2]]
        - 
        - ###############################################################################
        - ## Logical Combo [x,y] two index
        - 
       77 Base.getindex(x::LogicalCombo, row::Int, ::Colon; bool::Bool=false) =
        -   [ x[row,i] for i = !bool:size(x)[2] ]
        - 
        - Base.getindex(x::LogicalCombo, y::Union{Integer,Array}, col::String) = x[y, Symbol(col)]
        - 
        - Base.getindex(x::LogicalCombo, ::Colon, col::String) = x[:, Symbol(col)]
        - 
       10 Base.getindex(x::LogicalCombo, y::Union{Integer,Array{Int64}}, ::Colon) =
        -   hcat([ x[i,:] for i in collect(y) ]...)
        - 
        - Base.getindex(x::LogicalCombo, row::UnitRange, ::Colon) = x[collect(row),:]
        - 
        8 Base.getindex(x::LogicalCombo, ::Colon, col::Union{Int64,Symbol}; bool::Bool=false) =
        -   [ x[i,col] for i = 1:size(x)[1]]
        - 
        - # Base.getindex(x::LogicalCombo, ::Colon, col::Union{Int64,Symbol}) =
        - #   [ x[i,col] for i = 1:size(x)[1] ]
        - 
        - ###############################################################################
        - ## Logical Combo [x,y,z] three index
        4 Base.getindex(x::LogicalCombo, ::Colon, ::Colon, ::Colon)   =
        -   [x[i,j] for i in (1:size(x)[1])[x[:]], j in 1:size(x)[2]]
        - 
        - Base.getindex(x::LogicalCombo, ::Colon, ::Colon, z::Bool)   =
        -   [x[i,j] for i in (1:size(x)[1])[x[:] .== z], j in 1:size(x)[2]]
        - 
        - Base.getindex(x::LogicalCombo, ::Colon, y::Union{Int64,Symbol,String}, ::Colon) =
        -   [x[i,y] for i in (1:size(x)[1])[x[:]]]
        - 
      216 Base.getindex(x::LogicalCombo, ::Colon, y::Union{Int64,Symbol,String}, z::Bool) =
        -   [x[i,y] for i in (1:size(x)[1])[x[:] .== z]]
        - 
       42 Base.getindex(x::LogicalCombo, y::Int64 , ::Colon, ::Colon) =
        -   x[(1:size(x)[1])[x[:]][y],:]
        - 
       10 Base.getindex(x::LogicalCombo, y::Union{Int64, Array}, ::Colon, z::Bool) =
        -   x[(1:size(x)[1])[x[:] .== z][y],:]
        - 
        - Base.getindex(x::LogicalCombo, j::Int64, y::Union{Int64,Symbol,String}, z::Bool) =
        -   x[(1:size(x,1))[x[:] .== z][j],y]
        - 
        - 
        - ###############################################################################
        - ## Logical Combo [x,y;] two index with named arguments
        - 
        0 Base.getindex(x::LogicalCombo, ::Colon, ::Colon; bool=false, varnames=false) =
        -   collect(x,bool=bool,varnames=varnames)
        - 
        - ###############################################################################
        - # Set index!
        - Base.setindex!(x::LogicalCombo, y::Union{Int64,UnitRange}) =  x.logical[y]
        - 
        - Base.setindex!(x::LogicalCombo, y::Bool, z::Integer)   = x.logical[z] = y
        - Base.setindex!(x::LogicalCombo, y::Bool, z::Union{UnitRange, AbstractArray}) =
        -   x.logical[z] .= y
       26 Base.setindex!(x::LogicalCombo, y::Union{Array{Bool},Array{Bool,1},BitArray{1}}, ::Colon) = x.logical[:] .= y
        - 
        - Base.setindex!(x::LogicalCombo, y::Union{Array{Bool},Array{Bool,1}}, z::Union{UnitRange, AbstractArray}) =
        -   x.logical[z] = y
        - 
        - ###############################################################################
        - # Extra Functions
        - 
        7 Base.fill(v; each::Integer) = collect(Iterators.flatten([fill(x, each) for x in v]))
        - 
        - function Base.range(x::LogicalCombo; feasible=true)
        0   p = Dict()
        0   for i in 1:size(x,2); p[x.keys[i]] = sort(unique(x[:,i,feasible])); end
        0   p
        - end
        - 
        - Base.range(x::LogicalCombo, y::String; feasible=true) =
        -   Dict(Symbol(y) => x[:, Symbol(y), feasible] |> unique |> sort)
        - 
       60 variablerange(x::LogicalCombo; feasible=true) = [unique(x[:,i,feasible]) for i in 1:size(x,2)]
        - 
      230 nfeasible(x::LogicalCombo; feasible::Bool=true) =
        -   (feasible ? sum(x.logical) : size(x,1) - sum(x.logical))
        - 
        5 nfeasible(x::LogicalCombo, feasible::Bool) = nfeasible(x::LogicalCombo; feasible=feasible)
        - 
       40 percievedfeasible(x::LogicalCombo) = prod(length.(variablerange(x)))
        - 
        - using StatsBase
        - 
        - function StatsBase.sample(x::LogicalCombo; n=1, feasible=true)
       14   if nfeasible(x) == 0
        0     return []
        7   elseif nfeasible(x) == 1
        2     return x[:,:,:]
        -   else
        5     y = x[sample(1:nfeasible(x, feasible), n, replace=false),:,feasible]
        5     return sort(y, dims=1)
        -   end
        - end
        - 
        - StatsBase.sample(x::LogicalCombo, n; feasible=true) = sample(x, n=n, feasible=feasible)
        - StatsBase.sample(x::LogicalCombo, n, feasible) = sample(x, n=n, feasible=feasible)
        - 
