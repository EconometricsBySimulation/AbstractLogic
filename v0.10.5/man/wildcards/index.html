<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wildcards · AbstractLogic.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractLogic.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../command_syntax/">Command Snytax</a></li><li><a class="toctext" href="../repl/">RELP</a></li><li><a class="toctext" href="../generators/">Generators</a></li><li><a class="toctext" href="../operators/">Operators</a></li><li><a class="toctext" href="../superoperators/">Super Operators</a></li><li><a class="toctext" href="../metaoperators/">Meta Operators</a></li><li class="current"><a class="toctext" href>Wildcards</a><ul class="internal"><li><a class="toctext" href="#i-Reference-Wildcards-1"><code>i</code> Reference Wildcards</a></li><li><a class="toctext" href="#i-Modifiers-Index-Modifiers-1"><code>i</code> Modifiers - Index Modifiers</a></li><li><a class="toctext" href="#Variable-Reference-Wildcards-1">Variable Reference Wildcards</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li><li><a class="toctext" href="#Attributes-(j)-1">Attributes (j)</a></li></ul></li><li><a class="toctext" href="../queries/">Queries</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../../lib/functions/">Functions</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/harrypotter/">Harry Potter</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User Guide</li><li><a href>Wildcards</a></li></ul><a class="edit-page" href="https://github.com/EconometricsBySimulation/AbstractLogic.jl/blob/master/docs/src/man/wildcards.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Wildcards</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Wildcards-1" href="#Wildcards-1">Wildcards</a></h1><p>Wildcards allow for constraints which are uniformly applied across variables or sets of variables to be efficiently expressed. Uniform constraints are very common in abstract reasoning problems.</p><p>One constraint is that each variable must take on a different values from each other variable. This is expressed typically as <code>{{i}} != {{!i}}</code> or more efficiently <code>{{i}} != {{&gt;i}}</code>.</p><p>The placeholder variable <code>i</code> represents all variable names while <code>!i</code> represents for any given <code>i</code> all variables not named <code>i</code>. What <em>AbstractLogic</em> does when it encounters wildcards is loop through possible matches <em>spawning</em> new constraints based on the wildcards present in the current constraint.</p><h5><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h5><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :2 1 1

abstractlogic&gt; {{i}} &gt; {{&lt;i}}
{{i}} &gt; {{&lt;i}}
&gt;&gt;&gt; b &gt; a
&gt;&gt;&gt; c &gt; a
&gt;&gt;&gt; c &gt; b
                 feasible outcomes 1 ✓✓          :1 2 3</code></pre><p>In the above example we can see that three constraints were spawned from the input <code>{{i}} &gt; {{&lt;i}}</code>. This is because <code>i</code> is first given the variable name <code>a</code> but the right hand side takes value <code>&lt;i</code> which means in terms of the variable set this term can take any values to the left of <code>i</code> which is this case is no values. So <code>a</code> is skipped for the <code>i</code> value. Next <code>i</code> is set to <code>b</code>. <code>b</code> only has one variable to the left <code>a</code>. This is evaluated. Next we look at <code>c</code> which has both <code>a</code> and <code>b</code> to the left which are evaluated. Finally the parser combined the joint feasibility of the three generated constraints and only keeps values in which all three are true. In this case, <code>a=1, b=2, c=3</code>.</p><h2><a class="nav-anchor" id="i-Reference-Wildcards-1" href="#i-Reference-Wildcards-1"><code>i</code> Reference Wildcards</a></h2><ul><li><code>{{i}}</code> the most basic wildcard reference is <code>{{i}}</code>. It can take any variable name from the set of variables so far defined.</li></ul><h4><a class="nav-anchor" id="Example-2" href="#Example-2">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} == 1
{{i}} == 1
&gt;&gt;&gt; a == 1
&gt;&gt;&gt; b == 1
&gt;&gt;&gt; c == 1
                 feasible outcomes 1 ✓✓          :1 1 1</code></pre><ul><li><code>{{!i}}</code> any variable not <code>i</code>.</li></ul><p><strong>NOTE</strong> In general <code>!i</code> is not that helpful as there are few operations which <code>!i</code> does not return an empty set. And those cases in which it doesn&#39;t seem to be more efficiently expressed as <code>&gt;i</code> or <code>&lt;i</code>.</p><h4><a class="nav-anchor" id="Example-3" href="#Example-3">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} == {{!i}}
{{i}} == {{!i}}
&gt;&gt;&gt; a == b
&gt;&gt;&gt; a == c
&gt;&gt;&gt; b == a
&gt;&gt;&gt; b == c
&gt;&gt;&gt; c == a
&gt;&gt;&gt; c == b
                 feasible outcomes 3 ✓           :3 3 3</code></pre><ul><li><code>{{&gt;i}}</code> any variable to the right of wildcard <code>i</code>.</li></ul><h4><a class="nav-anchor" id="Example-4" href="#Example-4">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} == {{&gt;i}}
{{i}} == {{&lt;i}}
&gt;&gt;&gt; b == a
&gt;&gt;&gt; c == a
&gt;&gt;&gt; c == b
                 feasible outcomes 3 ✓           :3 3 3</code></pre><ul><li><code>{{&lt;i}}</code> any variable to the left of <code>i</code>.</li></ul><h4><a class="nav-anchor" id="Example-5" href="#Example-5">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} == {{&lt;i}}
{{i}} == {{&lt;i}}
&gt;&gt;&gt; b == a
&gt;&gt;&gt; c == a
&gt;&gt;&gt; c == b
                 feasible outcomes 3 ✓           :3 3 3</code></pre><ul><li><code>{{&lt;&lt;i}}</code> any variable at least two to the left of <code>i</code>.</li></ul><h4><a class="nav-anchor" id="Example-6" href="#Example-6">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} == {{&lt;&lt;i}}
{{i}} == {{&lt;&lt;i}}
&gt;&gt;&gt; c == a
         feasible outcomes 9 ✓           :3 1 3</code></pre><ul><li><code>{{&gt;&gt;i}}</code> any variable at least two to the right of <code>i</code>.</li></ul><h4><a class="nav-anchor" id="Example-7" href="#Example-7">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} == {{&gt;&gt;i}}
{{i}} == {{&gt;&gt;i}}
&gt;&gt;&gt; a == c
         feasible outcomes 9 ✓           :2 1 2</code></pre><h2><a class="nav-anchor" id="i-Modifiers-Index-Modifiers-1" href="#i-Modifiers-Index-Modifiers-1"><code>i</code> Modifiers - Index Modifiers</a></h2><ul><li><code>{{i+n}}</code>, <code>{{i-n}}</code> takes n steps right <code>+</code> or left <code>-</code> of <code>i</code>.</li></ul><h4><a class="nav-anchor" id="Example-8" href="#Example-8">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} != {{i+1}}
{{i}} != {{i+1}}
&gt;&gt;&gt; a != b
&gt;&gt;&gt; b != c
         feasible outcomes 12 ✓          :1 2 1</code></pre><ul><li><code>{{i+n!}}</code>, <code>{{i-n!}}</code> forces n steps right <code>+</code> or left <code>-</code> of <code>i</code>. If that step cannot be taken the variable is replaced by <code>999</code> which with numeric comparisons this will have different effects.</li></ul><h4><a class="nav-anchor" id="Example-9" href="#Example-9">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} = 1 ==&gt; {{i+1!}} = 2
{{i}} = 1 ==&gt; {{i+1!}} = 2
&gt;&gt;&gt; a = 1 ==&gt; b = 2
&gt;&gt;&gt; b = 1 ==&gt; c = 2
&gt;&gt;&gt; c = 1 ==&gt; 999 = 2
         feasible outcomes 12 ✓          :1 2 3</code></pre><h2><a class="nav-anchor" id="Variable-Reference-Wildcards-1" href="#Variable-Reference-Wildcards-1">Variable Reference Wildcards</a></h2><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><ul><li><code>{{N}}</code> evaluates every permutation given the wildcard set and evaluates the entire expression as <code>true</code> only if the number of values across wildcards is equal to <code>N</code>.</li></ul><p><strong>Note</strong> <code>{{N}}</code> must appear at the end of the <em>superoperator</em> expression.</p><h4><a class="nav-anchor" id="Example-10" href="#Example-10">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} = 2 {{2}}
{{i}} = 2 {{2}}
&gt;&gt;&gt; a = 2
&gt;&gt;&gt; b = 2
&gt;&gt;&gt; c = 2
                 feasible outcomes 6 ✓           :2 2 3</code></pre><p>Forces at least two variables from <code>a</code>, <code>b</code>, and <code>c</code> to equal <code>2</code>.</p><ul><li><code>{{n1,n2}}</code> evaluates every permutation given the wildcard set and evaluates the entire expression as <code>true</code> only if the number of values across wildcards is at least <code>n1</code> and no more than <code>n2</code>. If <code>n1</code> is empty then it is set to zero. If <code>n2</code> is empty it is set to a large number.</li></ul><p><strong>Note</strong> <code>{{n1,n2}}</code> must appear at the end of the <em>superoperator</em> expression. <strong>Hint</strong> <code>{{,n2}}</code> can be read as &quot;at most&quot; while <code>{{n1,}}</code> can be read &quot;at least&quot;.</p><h4><a class="nav-anchor" id="Example-11" href="#Example-11">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a,b,c ∈ 1:3
a,b,c ∈ 1:3              feasible outcomes 27 ✓          :1 1 3
abstractlogic&gt; {{i}} = 3 {{1,2}}
{{i}} = 3 {{1,2}}
&gt;&gt;&gt; a = 3
&gt;&gt;&gt; b = 3
&gt;&gt;&gt; c = 3
         feasible outcomes 18 ✓          :2 3 3</code></pre><p>Forces at least one or two of the variables to equal <code>3</code>.</p><h2><a class="nav-anchor" id="Attributes-(j)-1" href="#Attributes-(j)-1">Attributes (j)</a></h2><p>Variables attributes can be specified as <code>varname.attribute</code> and are treated as a variable except that attributes can be ignored by alternative wildcard <code>j</code>.</p><ul><li><code>{{j}}</code> <code>j</code> is exactly the same as <code>i</code> except that it ignores the parts of variable names that come after <code>.</code>s. So <code>a.1</code> just becomes <code>a</code> in the substitution mechanism.</li></ul><h4><a class="nav-anchor" id="Example-12" href="#Example-12">Example</a></h4><pre><code class="language-julia">abstractlogic&gt; a.1,a.2 ,b.1 ,b.2, c.1, c.2  ∈ 1:3
a.1,a.2 ,b.1 ,b.2, c.1, c.2  ∈ 1:3       feasible outcomes 729 ✓         :2 3 3 2 3 1
abstractlogic&gt; {{j}}.1 &lt; {{j}}.2
{{j}}.1 &lt; {{j}}.2
&gt;&gt;&gt; a.1 &lt; a.2
&gt;&gt;&gt; b.1 &lt; b.2
&gt;&gt;&gt; c.1 &lt; c.2
         feasible outcomes 27 ✓          :1 2 1 2 1 3

abstractlogic&gt; back
Last command: &quot;a.1,a.2 ,b.1 ,b.2, c.1, c.2  ∈ 1:3&quot; - Feasible Outcomes: 729     :1 3 2 1 2 3

abstractlogic&gt; {{j}}.1 == {{j+1}}.2
{{j}}.1 == {{j+1}}.2
&gt;&gt;&gt; a.1 == b.2
&gt;&gt;&gt; b.1 == c.2
         feasible outcomes 81 ✓          :3 1 1 3 1 1</code></pre><footer><hr/><a class="previous" href="../metaoperators/"><span class="direction">Previous</span><span class="title">Meta Operators</span></a><a class="next" href="../queries/"><span class="direction">Next</span><span class="title">Queries</span></a></footer></article></body></html>
