<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Command Snytax · AbstractLogic.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>AbstractLogic.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li class="current"><a class="toctext" href>Command Snytax</a><ul class="internal"><li><a class="toctext" href="#Line-Break-;-1">Line Break <code>;</code></a></li><li><a class="toctext" href="#Type-of-Operators-1">Type of Operators</a></li><li><a class="toctext" href="#Order-of-Operations-1">Order of Operations</a></li><li><a class="toctext" href="#A-Note-On-Wildcards-1">A Note On Wildcards</a></li></ul></li><li><a class="toctext" href="../repl/">RELP</a></li><li><a class="toctext" href="../generators/">Generators</a></li><li><a class="toctext" href="../operators/">Operators</a></li><li><a class="toctext" href="../superoperators/">Super Operators</a></li><li><a class="toctext" href="../metaoperators/">Meta Operators</a></li><li><a class="toctext" href="../wildcards/">Wildcards</a></li><li><a class="toctext" href="../queries/">Queries</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../../lib/functions/">Functions</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/harrypotter/">Harry Potter</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User Guide</li><li><a href>Command Snytax</a></li></ul><a class="edit-page" href="https://github.com/EconometricsBySimulation/AbstractLogic.jl/blob/master/docs/src/man/command_syntax.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Command Snytax</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Command-Flow-1" href="#Command-Flow-1">Command Flow</a></h1><p>Command flow follows a first in last out functional ruling with standard relational operators are evaluated first, then <em>superoperators</em>, then <em>metaoperators</em>. When <em>wildcards</em> are used, they generate code at the <em>superoperator</em> level which is evaluated.</p><h2><a class="nav-anchor" id="Line-Break-;-1" href="#Line-Break-;-1">Line Break <code>;</code></a></h2><p>Including <code>;</code> in a command will break the command into two or more separate commands.</p><h2><a class="nav-anchor" id="Type-of-Operators-1" href="#Type-of-Operators-1">Type of Operators</a></h2><p><code>logicalparse</code> takes four types operators. Generators, standard operators, superoperators, and metaoperators.</p><p><em>Generators</em>: <code>∈</code> and <code>in</code> are used to create or add to a <code>LogicalCombo</code>.</p><pre><code class="language-julia">abstractlogic&gt; a, b, c, d ∈ 0:2 [clear]
Clear Workspace
a, b, c, d ∈ 0:2         Feasible Outcomes: 81   Perceived Outcomes: 81 ✓        :1 0 0 2</code></pre><p><em>Standard Operators</em>: Take the form of one or two symbol operators and are often easily identified: <code>&gt;, &lt;, =, ==, !=</code> though there are many non-standard operators worth taking a look at.</p><p><em>Superoperators</em>: Evaluate the returns from operator expressions and hold three characters or lowercase strings <code>==&gt;, &lt;==, &lt;=&gt;, ===, !==, |||, &amp;&amp;&amp;, ^^^, !=&gt;</code> as well as <code>iff</code>, <code>if</code>, <code>then</code>, <code>and</code>, <code>or</code>, and <code>xor</code></p><p><em>Metaoperators</em>: Are made up of four characters or UPPERCASE characters <code>===&gt;, &lt;===, &lt;==&gt;, ====, !===, ||||, &amp;&amp;&amp;&amp;, ^^^^, !==&gt;</code></p><h2><a class="nav-anchor" id="Order-of-Operations-1" href="#Order-of-Operations-1">Order of Operations</a></h2><p>For most non-trivial problems order of operations is going to be very important for programming <code>AbstractReasoning</code> problems.</p><p><em>Standard operators</em> are evaluated first with their values returned first to <em>superoperators</em> if they exist and then to <em>metaoperators</em>.</p><p>Lets take a look at a example set, &quot;a, b, c ∈ 1:3&quot;. Let&#39;s say we wanted to specify that if a is less than b then c must greater than b (&quot;a &lt; b &lt;=&gt; c &gt; b&quot;).</p><pre><code class="language-julia">julia&gt; logicalparse(&quot;a, b, c ∈ 1:3; a &lt; b &lt;=&gt; c &gt; b&quot;) |&gt; showfeasible
a, b, c ∈ 1:3            feasible outcomes 27 ✓          :2 3 1
11×3 Array{Int64,2}:
 1  1  1
 1  2  3
 2  1  1
...
 3  3  1
 3  3  2
 3  3  3</code></pre><p>From the array above we can see that when a is less than b, c is greater than b and when a is not less than b, c is not greater than b.</p><p>The above statement uses a <em>superoperator</em> the <code>&lt;=&gt;</code> which is identical to <code>===</code> and <code>iff</code>. A <em>metaoperator</em> could functionally do the same as a <em>superoperator</em> in this case. But more complex conditional assertions might exist.</p><p>Lets imagine same scenario as before: (if a is less than b then c must greater than b) then (a must be the same as b and c) &quot;a &lt; b &lt;=&gt; c &gt; b ===&gt; a = b, c&quot;.</p><h3><a class="nav-anchor" id="Chaining-Operators-1" href="#Chaining-Operators-1">Chaining Operators</a></h3><p>Operators evaluated at the same level are always evaluated from left to right.</p><p>Initializing the repl (<code>julia&gt; =</code>). The <code>✓</code> is shorthand for <code>abstract logic&gt; check ... [silent]</code> calls silent check same</p><pre><code class="language-julia">abstractlogic&gt; a ∈ 1
a ∈ 1                    Feasible Outcomes: 1    Perceived Outcomes: 1 ✓✓        :1

abstractlogic&gt; ✓ true ==&gt; false
false

abstractlogic&gt; ✓ true &amp;&amp;&amp; false ==&gt; false
true

abstractlogic&gt; ✓ true &amp;&amp;&amp; false ==&gt; false &amp;&amp;&amp; false
false</code></pre><p>Formulating a problem. Let&#39;s say we would like a constraint specifies the only time <code>a</code> is less than or equal to <code>b</code> or <code>c</code>, is when <code>a</code>, <code>b</code>, and <code>c</code> are all equal.</p><pre><code class="language-julia">abstractlogic&gt; a, b, c ∈ 1:3; a &lt;= b ||| a &lt;= c ==&gt; a = b, c [clear]
Clear Workspace

a, b, c ∈ 1:3            Feasible Outcomes: 27   Perceived Outcomes: 27 ✓        :3 3 2
a &lt;= b ||| a &lt;= c ==&gt; a = b, c   Feasible Outcomes: 8    Perceived Outcomes: 27 ✓        :3 2 2

abstractlogic&gt; show
a b c
– – –
1 1 1
2 1 1
2 2 2
3 1 1
3 1 2
3 2 1
3 2 2
3 3 3</code></pre><h2><a class="nav-anchor" id="A-Note-On-Wildcards-1" href="#A-Note-On-Wildcards-1">A Note On Wildcards</a></h2><p>Wildcards <code>{{i}}</code> are spawned and evaluated at the level right above <em>superoperator</em> but below <em>metaoperators</em>. This allows mismatching wildcard functions to be handled on either side of a <em>metaoperator</em>. Let&#39;s say you only wanted values that either ascended monotonically or descended monotonically. You could do that using <code>{{i}} &lt; {{&lt;i}}</code> saying that all values to the right of <code>i</code> must be greater or <code>{{i}} &gt; {{&lt;i}}</code> saying that all values to the right of <code>i</code> must be smaller.</p><pre><code class="language-julia">julia&gt;  myset = logicalparse(&quot;a, b, c, d, e ∈ 1:6&quot;)
a, b, c, d, e ∈ 1:6      feasible outcomes 7776 ✓        :6 2 6 3 4

julia&gt;  logicalparse(&quot;{{i}} &lt; {{&lt;i}} |||| {{i}} &gt; {{&lt;i}}&quot;, myset) |&gt; showfeasible
logicalparse(&quot;{{i}} &lt; {{&lt;i}} |||| {{i}} &gt; {{&lt;i}}&quot;, myset) |&gt; showfeasible
{{i}} &lt; {{&lt;i}} |||| {{i}} &gt; {{&lt;i}}
&gt;&gt;&gt; b &lt; a
&gt;&gt;&gt; c &lt; a
...
&gt;&gt;&gt; e &gt; c
&gt;&gt;&gt; e &gt; d
feasible outcomes 12 ✓          :1 2 3 5 6
12×5 Array{Int64,2}:
1  2  3  4  5
1  2  3  4  6
1  2  3  5  6
...
6  5  4  2  1
6  5  4  3  1
6  5  4  3  2</code></pre><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="../repl/"><span class="direction">Next</span><span class="title">RELP</span></a></footer></article></body></html>
